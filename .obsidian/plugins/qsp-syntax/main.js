/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => QspSyntaxHighlightingPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian2 = require("obsidian");

// loadPrismWithQsp.ts
var import_obsidian = require("obsidian");
var applyPrismQsp = (Prism) => {
  const kw_operators = "\\b(act|addobj|cla|close|all|cls|cmdclear|copyarr|delact|delobj|dynamic|exit|gosub|goto|if|else|elseif|inclib|jump|killall|killobj|freelib|killvar|let|local|loop|menu|msg|opengame|openqst|play|refint|savegame|scanstr|set|settimer|showacts|showinput|showobjs|showstat|sortarr|unselect|view|wait|xgoto|addqst|killqst|unsel|cmdclr|gt|xgt|gs|exec)\\b";
  const kw_controls = "\\b(act|if|elseif|else|loop|while|step|end)\\b";
  const kw_text_operators = "\\*?\\b(pl?|nl|clr|clear)\\b";
  const functions_string = "\\$(desc|user_text|usrtxt|maintxt|stattxt|curloc|selobj|selact|mid|(u|l)case|trim|replace|str|strfind|input|qspver|curacts|getobj|iif|dyneval|func|max|min|arritem)\\b";
  const functions_num = "\\b(loc|obj|isnum|isplay|len|val|instr|strcomp|strpos|arrsize|arrpos|arrcomp|msecscount|rgb|countobj|ra?nd|iif|dyneval|func|max|min|arritem)\\b";
  const system_vars_string = "\\$(counter|ongload|ongsave|onnewloc|onactsel|onobjsel|onobjadd|onobjdel|usercom|fname|backimage|args|result)\\b";
  const system_vars_num = "\\b(nosave|disablescroll|disablesubex|debug|usehtml|(b|f|l)color|fsize|args|result)\\b";
  Prism.languages.qsp = {
    "comment": {
      pattern: /((^\s*?)|(\&\s*?))(![^\n{'"]*$)/m,
      lookbehind: true,
      greedy: true
    },
    "braced-comment": {
      pattern: /((^\s*?)|(\&\s*?))(![^\n{'"]*\{[^\}]*\}.*?$)/m,
      alias: "comment",
      lookbehind: true,
      greedy: true
    },
    "quoted-comment": {
      pattern: /((^\s*?)|(\&\s*?))((![^\n{'"]*"[^"]*".*?$)|(![^'\n\r]*'[^']*?'.*?$))/m,
      alias: "comment",
      lookbehind: true,
      greedy: true
    },
    "string": {
      pattern: /("|')(?:[\s\S]*?)\1/im,
      lookbehind: false,
      greedy: true
    },
    "function": {
      pattern: /\@[\w\.а-я]+(?=\s*\()/i
    },
    "start-location": /^\#\s*\S+.*$/im,
    "end-location": /^\-.*$/im,
    "label": {
      pattern: /^\s*:[^&\n]*(?=\&|$)/im,
      lookbehind: true,
      greedy: true
    },
    "sys-variable": RegExp(`(?:${system_vars_string}|${system_vars_num})`, "i"),
    "builtin": RegExp(`(?:(${functions_string}|${functions_num}))`, "i"),
    "number": /\b\d+\b/,
    "keyword": RegExp(`(?:${kw_text_operators}|${kw_operators}|${kw_controls})`, "i"),
    "declarator": /(?:\b(local|set|let)\b)/i,
    "operator": /[<>\+\-\*\/]=|<>|\+|\&|-|<|>|=|\/|\*|!|\b(and|or|mod|no)\b/i,
    "sign-punctuation": /[{}[\];(),:]/,
    "user-variable": /[\$\%][\wа-я]+|[\wа-я]+/i
  };
};
var loadPrismWithQsp = async () => {
  try {
    const Prism = await (0, import_obsidian.loadPrism)();
    applyPrismQsp(Prism);
    return Prism;
  } catch (error) {
    console.error("Failed to load Prism:", error);
    throw error;
  }
};
var loadPrismWithQsp_default = loadPrismWithQsp;

// qspHighlighter.ts
var import_view = require("@codemirror/view");
var import_state = require("@codemirror/state");
var QspHighlight = class {
  constructor(view) {
    this.decorations = import_view.Decoration.none;
    this.loadPrism().then(() => {
      this.decorations = this.buildDecorations(view);
      view.update([]);
    });
  }
  update(update) {
    if (update.viewportChanged || update.docChanged) {
      this.decorations = this.buildDecorations(update.view);
    }
  }
  async loadPrism() {
    this.prism = await loadPrismWithQsp_default();
  }
  buildDecorations(view) {
    const builder = new import_state.RangeSetBuilder();
    if (!this.prism) {
      return import_view.Decoration.none;
    }
    const text = view.state.doc.toString();
    const regex = /```qsp(?:[\s:!?.;,@%&(){}[\]<>*~]*)([\s\S]*?)\n```/gi;
    let match;
    while ((match = regex.exec(text)) !== null) {
      const codeBlock = match[0];
      const highlighted = this.prism.highlight(codeBlock, this.prism.languages.qsp, "qsp");
      const blockStart = match.index;
      this.applyHighlighting(highlighted, blockStart, builder);
    }
    return builder.finish();
  }
  applyHighlighting(highlighted, blockStart, builder) {
    const parser = new DOMParser();
    const doc = parser.parseFromString(highlighted, "text/html");
    const tempEl = doc.body;
    let currentIndex = blockStart;
    const ranges = [];
    const traverse = (node) => {
      if (node.nodeType === Node.TEXT_NODE) {
        const text = node.textContent || "";
        currentIndex += text.length;
      } else if (node.nodeType === Node.ELEMENT_NODE) {
        const element = node;
        const className = element.className;
        const start = currentIndex;
        element.childNodes.forEach((child) => {
          traverse(child);
        });
        const end = currentIndex;
        ranges.push({ start, end, className });
      }
    };
    tempEl.childNodes.forEach((child) => {
      traverse(child);
    });
    ranges.sort((a, b) => a.start - b.start);
    for (const range of ranges) {
      builder.add(
        range.start,
        range.end,
        import_view.Decoration.mark({ class: range.className })
      );
    }
  }
};

// main.ts
var import_view2 = require("@codemirror/view");
var QspSyntaxHighlightingPlugin = class extends import_obsidian2.Plugin {
  async onload() {
    try {
      console.log("Loading Qsp Syntax Highlighting Plugin");
      this.obsidianPrism = await loadPrismWithQsp_default();
      this.registerMarkdownPostProcessor((el, ctx) => {
        el.querySelectorAll("pre > code.language-qsp").forEach((block) => {
          this.obsidianPrism.highlightElement(block);
        });
      });
      this.registerEditorExtension(
        import_view2.ViewPlugin.fromClass(
          QspHighlight,
          {
            decorations: (plugin) => plugin.decorations
          }
        )
      );
      this.app.workspace.updateOptions();
    } catch (error) {
      console.error("Failed to load Prism: ", error);
    }
  }
  onunload() {
    console.log("Unloading Qsp Syntax Highlighting Plugin");
    if (this.obsidianPrism && this.obsidianPrism.languages.qsp) {
      delete this.obsidianPrism.languages.qsp;
    }
  }
};
