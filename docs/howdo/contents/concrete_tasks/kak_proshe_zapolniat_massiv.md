---
sidebar_position: 24
---

# 20.24. Как проще заполнять массив?
<!-- [:faq_20_24] -->
:::warning[**Внимание!!**]
Кортежи будут выделены в новый тип данных в версиях плеера выше 5.8.0, поэтому данный алгоритм требует пересмотра.
:::
В:
Нет ли способа упростить внесение первоначальных данных в массив? Чтобы не писать
```qsp
mass[0]=123
mass[1]=234
mass[2]=345
! и т.д.
```
а вместо этого написать что-то типа
```qsp
mass = [123, 234, 345]
``` 

О:

QSP предоставляет возможность самостоятельно писать любые функции, которые вам необходимы, в том числе и такие, которые будут упрощать ввод данных.

В данном случае мы можем написать функцию, которая будет принимать в качестве аргумента имя массива и кортеж значений, которые мы в этот массив хотим поместить, и с помощью цикла внутри функции извлечь из кортежа все значения в подряд идущие ячейки массива.

Вот как может выглядеть такая функция:

```qsp
!# full_array
$args[0] = $args[0] & ! название массива
$args[1] = $args[1]+"" & ! переданный кортеж (см. примечание)
if instr($args[0],'$')=1: $args[0]=$mid($args[0],2) & ! убираем из имени массива символ $
local instring, $cut & ! объявляем локальные переменные
loop while len($args[1])>0:
	! циклом перебираем строку значений (кортеж)
	instring=instr($args[1],"")
	$cut=$mid($args[1],1,instring-1)
	$args[1]=$mid($args[1],instring+1)
	! dynamic "$<<$args[0]>>[]=$args[0]",$cut & ! так мы будем помещать в массив строковые значения
	dynamic "<<$args[0]>>[]=args[0]",val($cut) & ! а так числовые
end
```

Теперь, когда нам нужно быстро записать в массив много значений, не расписывая на множество строчек присвоение каждой ячейке, мы просто вызываем функцию "`full_array`":

```qsp
! вносим в массив значения
@full_array('mass',(123,234,345))

! для проверки внесённых значений используем цикл
loop local i=0 while i<arrsize('mass') step i+=1:
	*pl mass[i]
end
```

Примечание: чтобы понимать, каким образом мы вытаскиваем данные из кортежа, нужно понимать, в каком виде в QSP представлен кортеж. Кортеж — это строка значений. Фактически это обычная строка, в которой все значения разделяются символом "``". Этот символ имеет код 0x1f. Именно эту особенность хранения данных мы и используем, чтобы извлечь значения из кортежа. Мы определяем, в какой позиции находится разделяющий символ, затем вырезаем строку до этого символа и помещаем в новую ячейку массива. Дальше работаем уже с оставшейся строкой.

Данная функция была реализована в [easy.math версии 3.0](https://github.com/AleksVersus/easy.math.3/blob/main/%5Bsource%5D/07_операции%20с%20массивами/99_em.arr.fill.qsps).
