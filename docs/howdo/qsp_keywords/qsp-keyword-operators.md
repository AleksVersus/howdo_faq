---
sidebar_position: 2
---

# Операторы
<!-- [:faq_80_02] -->

## Неявный оператор
<!-- [:faq_80_02_impicit] -->

Неявный оператор — это оператор, который не прописывается в коде QSP, но производит вывод значений на экран. Неявный оператор подразумевается везде, где в команде присутствует выражение без оператора. Неявный оператор выводит в **Окно основного описания** значения таким же образом, как если бы вы использовали явное указание оператора `*pl`, то есть выводит значение и совершает переход на новую строку. Примеры:

```qsp
$AAA + '989'
'Вы находитесь в парке'
'Преформатированная

	строка'
$curloc & ! выведет на экран название локации
```

В отличие от оператора `*pl` неявный оператор не выводит на экран пустую строку с переходом на новую строку, если ему не передаётся никакое значение. Это означает, что если функция не возвращает никакого значения, неявный оператор просто игнорируется. Пример:

```qsp
# start
! это код локации, вызывающей локацию-функцию
$curloc
$func('foo')
$func('foo')
$curloc
- start

# foo
! это код локации-функции
local i = 0
- foo
```

В данном случае локация-функция `foo` ничего не возвращает, поэтому на экране мы увидим две строки со словом "start", между которыми не будет пустых строк, так как неявный оператор в строках с `$func` на локации `start` будет просто проигнорирован. Сравните с:

```qsp
# start
! это код локации, вызывающей локацию-функцию
*pl $curloc
*pl $func('foo')
*pl $func('foo')
*pl $curloc
- start

# foo
! это код локации-функции
local i=0
- foo
```

## `!` (комментарий)
<!-- [:faq_80_02_comments] -->

`!` — оператор комментария. То, что находится в строке после оператора комментария, и до конца строки игнорируется интерпретатором. Оператор комментария позволяет "закомментировать" (выключить) ненужный временно оператор/функцию во время отладки игры. Кроме того, написание комментариев к коду программы является одним из признаков хорошего стиля программирования.

Необходимо чётко понимать, что это именно оператор, поэтому если вы комментируете некую строку кода, то `!` должен стоять после `&`:

```qsp
*pl "Hello, world!" & ! комментарий
```

Комментарии могут быть однострочными, то есть заканчиваться в той же строке, где стоит оператор комментария:
```qsp
! однострочный комментарий
*pl "строка текста" & ! тоже однострочный комментарий
```
Комментарии могут быть многострочными. Для этого после оператора комментария нужно записать кавычки, апострофы, или фигурные скобки. Например так:

```qsp
! "это первая строка коммантария
	это вторая строка комментария
	это третья строка комментария
"
```

Многострочные комментарии могут принимать самые разнообразные формы:

```qsp
! строка до  кавычек " текст внутри кавычек
может переходить на другие строки " а так же {
можно использовать другие группы символов, чтобы 
продолжать многострочный комментарий
} и комментарий не кончится, пока не кончится строка
```

## `*CLEAR`
<!-- [:faq_80_02_sclr] -->

`*CLEAR` — очищает окно основного описания. Имеет краткую форму `*clr`.

## `*NL`
<!-- [:faq_80_02_snl] -->

`*NL` — переход на новую строку, затем вывод текста в окне основного описания. Общая запись:
```qsp
*NL [$текст]
```

, где `[$текст]` — любая строка текста, число, или выражение любого типа. Если `[$текст]` отсутствует, происходит просто переход на новую строку. Пример:

```qsp
*p "Текст без перехода на новую строку."
*nl "Переход на новую строку + выведение текста."
*p "Текст без перехода на новую строку."
```

## `*P`
<!-- [:faq_80_02_sp] -->

`*P` — вывод текста в окно основного описания без перехода на новую строку. Вывод текста любым другим оператором сразу после `*p` добавит новый текст сразу после текущего. Общая запись:

```qsp
*P [$текст]
```

, где `[$текст]` — любая строка текста, число, или выражение любого типа. `[$текст]` может быть пустой строкой `''`, но не должен отсутствовать. Пример:

```qsp
*p "Текст без перехода на новую строку."
*p "Текст без перехода на новую строку."
*p ""
*p "Текст без перехода на новую строку."
```

## `*PL`
<!-- [:faq_80_02_spl] -->

`*PL` — вывод текста в окно основного описания, затем переход на новую строку. Общая запись:

```qsp
*PL [$текст]
```
 
 где `[$текст]` — любая строка текста, число, или выражение любого типа. `[$текст]` может отсутствовать, тогда просто переход на новую строку. Пример:
 
```qsp
*pl "Вывод текста, затем переход на новую строку."
*pl "Вывод текста, затем переход на новую строку."
*p "Текст без перехода на новую строку."
*pl "Вывод текста, затем переход на новую строку."
```

Аналогичным образом можно вывести текст, просто написав нужное выражение вместо данного оператора. Например, строки:

```qsp
*pl $AAA + '989'
*pl 'Вы находитесь в парке'
*pl 'Преформатированная

	строка'
```

и:

```qsp
$AAA + '989'
'Вы находитесь в парке'
'Преформатированная

	строка'
```

сработают одинаково.

## ACT
<!-- [:faq_80_02_act] -->

`ACT` — создаёт и выводит в окно действий новое действие.
	
Общая запись в однострочной форме:

```qsp
ACT [$название], [$путь к файлу изображения]: [оператор] & [оператор] & [оператор]
```

Общая запись в многострочной форме:

```qsp
ACT [$название], [$путь к файлу изображения]:
	[оператор]
	[оператор]
	[оператор]
END
```

К списку действий в окне действий добавляется новое с названием `[$название]` и изображением, которое лежит по пути `[$путь к файлу изображения]`. При нажатии на действие выполняются заданные операторы.

Параметр `[$путь к файлу изображения]` может отсутствовать, при этом действие добавится без изображения.

Примеры:

```qsp
! действие в однострочной форме записи
act "Сорвать с берёзы яблоко": яблоко += 1 & *pl "Вы сорвали яблоко, спелое белое."

! действие в многострочной форме записи, с изображением
act "Сорвать арбуз с куста", "img/watermelon.png":
	арбуз += 1
	*pl "Вы сорвали арбуз с куста"
end
```

Если в списке действий уже есть действие с указанным названием, то новое действие не создаётся, и не заменяет собой уже существующее, плеер просто игнорирует команду `act`. Таким образом нельзя вывести действия с одинаковыми названиями. Пример:

```qsp
act "Действие 1": *pl "Старое действие."
act "Действие 1": *pl "Новое действие."
```

Однако, вы можете сымитировать действия с одинаковыми названиями в режиме распознавания HTML, добавив в названия действий HTML-тег:

```qsp
usehtml = 1
act 'Действие 1<a data-avs="uid-old"></a>': *pl "Старое действие."
act 'Действие 1<a data-avs="uid-new"></a>': *pl "Новое действие."
```

## ADDOBJ
<!-- [:faq_80_02_addobj] -->

`ADDOBJ` — добавление нового предмета в окно предметов. Общая запись:

```qsp
ADDOBJ [$название], [$путь к файлу изображения], [#позиция]
```

, где `[$название]` — это название предмета, `[$путь к файлу изображения]` — это путь к файлу изображения предмета (отображается рядом с названием предмета), а `[#позиция]` — на какое место в инвентаре добавляется предмет. Параметр `[#позиция]` может отсутствовать. По умолчанию предметы добавляются в конец списка. Нумерация предметов в инвентаре ведётся с `1`. Параметр `[$путь к файлу изображения]` может отсутствовать, значение по умолчанию - `''`, при этом предмет добавляется без изображения.

:::note
Допустима, но не рекомендуется, запись:

```qsp
ADD OBJ [$название],[$путь к файлу изображения],[#индекс]
```
:::

Можно добавлять предметы с одинаковым названием, однако если вы планируете добавлять много одинаковых предметов, то лучше использовать дополнительную переменную для подсчёта этих предметов, а в окно предметов добавить один предмет, чтобы не загромождать инвентарь списком из 137 предметов Рубль / Патрон:

```qsp
if obj 'Патроны':
! если предмет "Патроны" уже добавлен, просто увеличиваем их число
	патроны += 10
else
! если предмет "Патроны" ещё не добавлен, добавляем, и увеличиваем число
	addobj 'Патроны'
	патроны += 10
end
```

Для хранения числа предметов можно использовать массивы, индексируемые через строки:

```qsp
objects['деньги'] = 12
objects['патроны'] = 137
'Количество: <<objects[$getobj(countobj)]>>'
```

Пример добавления предмета в самый верх списка (при этом все остальные предметы сместятся вниз):

```qsp
addobj "Отвёртка", "", 1
```

## CLA
<!-- [:faq_80_02_cla] -->

`CLA` - очистка списка текущих действий (удаление всех действий из окна действий).

## CLEAR
<!-- [:faq_80_02_clear] -->

`CLEAR` — очищает окно дополнительного описания. Имеет краткую форму `clr`.

## CLOSE
<!-- [:faq_80_02_close] -->

`CLOSE` — останавливает проигрывание указанного звукового файла. Общая запись:

```qsp
CLOSE [$путь к звуковому файлу]
```

, где `[$путь к звуковому файлу]` — путь к звуковому файлу относительно файла игры. Если параметр `[$путь к звуковому файлу]` не указан, происходит остановка воспроизведения всех звуковых файлов.

## CLOSE ALL
<!-- [:faq_80_02_closeall] -->

`CLOSE ALL` — остановка проигрывания всех активных звуковых файлов. Имеет краткую форму `close`.

## CLS
<!-- [:faq_80_02_cls] -->

`CLS` — очищает все окна кроме списка предметов. Эквивалентно конструкции:

```qsp
clear & *clear & cla & cmdclear
```

## CMDCLEAR
<!-- [:faq_80_02_cmdclear] -->

`CMDCLEAR` — очистка строки ввода. Имеет краткую форму `cmdclr`.

## COPYARR
<!-- [:faq_80_02_copyarr] -->

`COPYARR` — копирование содержимого одного массива в другой. Общая запись:

```qsp
COPYARR [$приёмник], [$источник], [#начало], [#количество]
```

, где: `[$приёмник]` — это массив, в который производится копирование, размер и наполнение значения не имеют; `[$источник]` — это массив, из которого производится копирование; `[#начало]` — номер элемента, с которого нужно начинать копирование; `[#количество]` — сколько элементов нужно скопировать. Параметр `[#количество]` является необязательным; по умолчанию — до конца массива-источника. Параметр `[#начало]` является необязательным; по умолчанию — 0.

Примеры:

```qsp
! копируем все элементы массива '$b' в массив '$a'
copyarr '$a', '$b'
! при этом так же были скопированны все элементы массива 'b' в массив 'a'

! копируем в массив 'c' элементы массива 'd', начиная с шестого
copyarr 'c', 'd', 6

! копируем шесть первых элементов массива 'd' в массив 'c'
copyarr 'c', 'd', 0, 6
```

В силу особенностей плеера при копировании, например, числового массива `mass1` в `mass2` копируется также текстовый массив `$mass1` в `$mass2`.

Другие примеры:

```qsp
copyarr $arrname1, $arrname2, 10, 5
copyarr 'a<<$arrname1>>', 'a<<$arrname2>>'
```

## DELACT
<!-- [:faq_80_02_delact] -->

`DELACT` — удаляет действие из списка действий (если такое действие существует). Общая запись:

```qsp		
DELACT [$название]
```

, где `[$название]` — название действия, которое хотим удалить.

Примеры:

```qsp
! удаляем действие с конкретным названием
delact 'Идти вперед'
! удаляем выделенное действие
delact $selact
```

:::note
Допустима, но не рекомендуется, устаревшая форма записи:

```qsp
DEL ACT [$название]
```
:::

## DELOBJ
<!-- [:faq_80_02_delobj] -->

`DELOBJ` — удаление предмета из инвентаря по названию (если такой предмет существует). Общая запись:

```qsp
DELOBJ [$название]
```

, где `[$название]` — название предмета, который хотим удалить.

Если в инвентаре присутствуют одинаковые предметы, команда удалит самый верхний с указанным индексом.

Примеры:

```qsp
! удаляем предмет с конкретным названием
delobj "Отвёртка"
! удаляем выделенный предмет
delobj $selobj
```

:::note
Допустима, но не рекомендуется, устаревшая форма записи:

```qsp
DEL OBJ [$название]
```
:::

## DYNAMIC
<!-- [:faq_80_02_dynamic] -->

`DYNAMIC` — выполняет код, переданный в виде строки текста. Общая запись:

```qsp
	DYNAMIC([$код], [аргумент 0], [аргумент 1], ... , [аргумент 18])
```

, где `[$код]` — это обычный код QSP, записанный в виде текста. Выполнение такого кода аналогично выполнению кода оператора `GOSUB`. Аргументы `[аргумент 0]`, `[аргумент 1]` и т.д. могут использоваться внутри `[$код]`, их значения автоматически помещаются в переменные `args[0]`, `args[1]`, и т.д. соответственно. После выполнения старые параметры `args` восстанавливаются, затем продолжается выполнение кода со следующей команды после `dynamic`.

Примеры:

```qsp
dynamic '$a = "string<<$b>>"'
dynamic '$a'
dynamic 'if $a = "string": "text!"'
dynamic "
	$args[0]
	addobj $args[1]
", 'Текст', 'Вилка'
```

Нижеследующая информация справедлива и для функции `dyneval` (см. [соответствующий раздел](#faq_80_03_dyneval)).

Важно! Если код задан с помощью апострофов (`''`) или кавычек (`""`), в тексте вычисляются подвыражения:

```qsp
$args[0] = 'qwerty'
$code = '
	*pl "<<$args[0]>>"
	*pl $args[0]
'
 
dynamic $code, 'asdfg'
```

В этом случае при задании переменной `$code` будет вычислено подвыражение, поэтому первой строкой выведется 'qwerty', второй строкой выведется 'asdfg'.

Фигурные скобки - третий вид кавычек используемый специально для написания динамического кода. Здесь поддерживается вложенность скобок, а перед выполнением кода не вычисляются подвыражения:

```qsp
$args[0]='qwerty'
$code = {
	*pl "<<$args[0]>>"
	*pl $args[0]
}

dynamic $code, 'asdfg'
```

В этом случае будут выведены две строки 'asdfg'.

## EXIT
<!-- [:faq_80_02_exit] -->

`EXIT` — завершение выполнения текущего блока кода (преждевременный выход из подпрограммы, функции, обработчика какого-либо события, и т.д.).

В качестве блока кода может выступать локация, действие, код, переданный `dynamic`'у или `dyneval`'у, или код в гиперссылке.

Пример:

```qsp
if args[1] = 0:
	exit
else
	if args[0] mod args[1] = 0:
		result = 1
	else
		result = 0
	end
end
```

:::warning[Внимание!!!]
В плеерах версии 5.8.0 появился оператор цикла `loop`.

Тело цикла так же считается отдельным блоком кода, однако оператор `exit` прерывает не только сам цикл, но и блок кода, в котором находится цикл.
:::

## GOSUB
<!-- [:faq_80_02_gosub] -->

`GOSUB` — выполнение кода указанной локации без непосредственного перехода на неё.

Общая запись:

```qsp
GOSUB [$локация],[аргумент 0],[аргумент 1], ... ,[аргумент 8]
```

, где `[$локация]` — это название локации, код которой мы хотим выполнить без непосредственного перехода на неё. Аргументы `[аргумент 0]`, `[аргумент 1]` и т.д. могут использоваться на этой локации, их значения автоматически помещаются в переменные `args[0]`, `args[1]`, и т.д. соответственно. После обработки локации предыдущие значения `args` восстанавливаются. Использование аргументов не обязательно.

При обращении к локации по `gosub` базовое описание локации добавляется к текущему описанию, базовые действия добавляются к текущим действиям, и происходит выполнение операторов в поле "Выполнить при посещении", затем возврат на исходную строку (продолжение выполнения кода после `gosub`).

Примеры вызова локаций по `gosub`:

```qsp
!обработка локации "ход". Массив args[] пуст.
gosub 'ход'

!обработка локации с названием из переменной $loc
!Передаётся один параметр - args[0] равен 1.
gosub $location,1

!обработка локации "ход" с передачей 3-х параметров. 
! $args[0] = $var (значению), args[1] = 2, 
! $args[2] = "данные". Обратите внимание на символы '$'.
gosub 'ход',$var,2,'данные'
```

Ещё пример:

```qsp
! это код вызова локации "переход"
gosub 'переход', 'локация'

! а это код самой локации "переход"
# переход
*pl $args[0]  & ! на экран выведется текст 'локация'
! в окне действий появится новое действие:
act 'перейти':
	goto "улица"
end
- переход
```

Оператор имеет краткую форму `gs`:

```qsp
GS [$локация], [аргумент 0], [аргумент 1], ... , [аргумент 18]
```

## GOTO
<!-- [:faq_80_02_goto] -->

`GOTO` — переход на указанную локацию. Общая запись:

```qsp
GOTO [$локация], [аргумент 0], [аргумент 1], ... , [аргумент 18]
```

, где `[$локация]` — название локации, на которую должен быть осуществлён переход. Аргументы `[аргумент 0]`, `[аргумент 1]` и т.д. могут использоваться на этой локации, их значения автоматически помещаются в переменные `args[0]`, `args[1]`, и т.д. соответственно. Использование аргументов не обязательно.

При переходе на новую локацию при помощи `goto` очищается окно основного описания, а также список текущих действий, затем в окно основного описания выводится текст базового описания, в окно действий — базовые действия, а так же выполняется код из поля "Выполнить при посещении" локации `[$локация]`. Так же при переходе на новую локацию изменяется значение, возвращаемое функцией `$curloc`.

Примеры:

```qsp
! переход на локацию "дом".
! Массив args на локации "дом" будет пуст.
goto 'дом'

! переход на локацию "улица" с передачей 2-х параметров.
! на локации "улица" args[0] равен 1,
! $args[1] содержит строку "данные".
goto 'улица',1,'данные'
```

Оператор имеет краткую форму `gt`:

```qsp
GT [$локация],[аргумент 0],[аргумент 1], ... ,[аргумент 8]
```

## IF (ELSE, ELSEIF)
<!-- [:faq_80_02_if] -->

`IF` — оператор условия. Собственно для того и нужен, чтобы проверять выполнение какого-либо условия. Имеет несколько форм записи.

Простая однострочная форма записи:

```qsp
IF [#выражение]: [команда 1] & [команда 2] & ...
```

Как видите, за ключевым словом `if` следует выражение `[#выражение]`, и если это выражение верно, тогда выполняется набор команд `[команда 1]`, `[команда 2]`, и т.д., которые записаны после двоеточия в той же строке. При этом команды перечисляются через амперсанд (`&`).

Именно по наличию команд сразу в той же строке после двоеточия плеер определяет, что это однострочная форма, и считает конец этой строки концом конструкции условия.

Примеры:

```qsp
! если сумма a и b равна двум,
! переменной c присваивается значение 30
if a + b = 2: c = 30
! Если в инвентаре нет апельсина, выводится текст
if no obj("Апельсин"): pl "У Вас нет апельсина."
! это тоже простая однострочная форма
if ((a+b)/c)=45+54 or (b<5 or c>45) and no obj 'лопата' and $f=$vvv+'RRRRR': p 'OK' & goto 'Next'
```

Сложная однострочная форма записи:

```qsp
IF [#выражение]: [команда д1] & [команда д2] & ... ELSE [команда н1] & [команда н2] & ...
```

Здесь снова за ключевым словом `if` следует `[#выражение]`, истинность которого требуется проверить. Если выражение верно, выполняется набор команд `[команда д1]`, `[команда д2]` и т.д., от двоеточия до ключевого слова else. В противном случае, если выражение `[#выражение]` неверно, выполняется набор команд `[команда н1]`, `[команда н2]` и т.д., от `else` и до конца строки. Точно так же, как и для простой однострочной формы, концом конструкции условия считается конец строки.

Примеры сложной однострочной формы:

```qsp
! если сумма a и b равна двум, переменной c присваивается значение 30
! в противном случае (то есть если сумма a и b не равна двум)
! переменной c присваивается значение 10
if a+b=2: c=30 else c=10
! в зависимости от того есть ли в инвентаре апельсин
! выводится соответствующий текст
if obj "Апельсин": pl "У Вас есть апельсин." else pl "У Вас нет апельсина."
```

Простая многострочная форма записи в общем виде выглядит вот так:

```qsp
IF [#выражение]:
	[команда 1]
	[команда 2]
	...
END
```

Как видите, она отличается от простой однострочной формы записи тем, что команды `[команда 1]`, `[команда 2]` и т.д. записаны не сразу после двоеточия, а только в следующей строке. Именно так плеер понимает, что имеет дело с многострочной формой записи. Наличие или отсутствие пробелов или символов табуляции перед командами роли не играет, однако, чтобы плеер понял, где заканчивается конструкция условия, в конце на отдельной строке необходимо прописывать ключевое слово `end`, или `end if`.

Примеры:

```qsp
if библиотека = 0:
	узнал_о_тусовке = 0
	библиотека_вернулся = 1
	gt 'библиотека'
end

if a+b=2:
	c=30
end
```

Сложная многострочная форма в общей записи выглядит вот так:

```qsp
IF [#выражение]:
	[команда д1]
	[команда д2]
	...
ELSE
	[команда н1]
	[команда н2]
	...
END
```

Здесь так же команды `[команда д1]`, `[команда д2]` и т.д. записываются не сразу после двоеточия, а только в следующей строке. Ключевое слово else так же записывается в отдельной строке, и команды `[команда н1]`, `[команда н2]` и т.д. идут в последующих строках после `else`. Завершается конструкция условия ключевым словом `end` (или `end if`), которое снова идёт отдельной строкой.

При верности выражения `[#выражение]` выполняется набор команд между двоеточием и `else`, а если `[#выражение]` неверно, выполняется набор команд между `else` и `end`.

Примеры:

```qsp
if a+b=2:
	c=30
else
	c=10
end

if obj("Апельсин"):
	pl "У Вас есть апельсин."
else
	pl "У Вас нет апельсина."
end

if len($curtoken) > 0:
	$tokens[curtoken] = $curtoken
	tokens = curtoken + 1
else
	tokens = curtoken
end
```

Ещё одна форма записи работает только в многострочном варианте (обещали исправить в новых версиях). Это расширенная форма. Она позволяет размещать на одном уровне вложенности последовательно-исключающие условия. Общая форма записи такая:

```qsp
IF [#выражение 1]:
	[набор команд 1]
	...
ELSEIF [#выражение 2]:
	[набор команд 2]
	...
ELSEIF ... :
	...
ELSE
	[последний набор команд]
	...
END
```

Правила записи такие же, как и для других видов многострочных условий. После двоеточия в той же строке, где находится оператор `if` или `elseif` не должно идти никаких команд, только со следующей строки. Вся конструкция должна заканчиваться оператором `end` (или `end if`), стоящим в отдельной строке. В конструкции может как присутствовать, так и отсуствовать часть с `else`.

Работает это следующим образом. Если `[#выражение 1]` верно, выполняются команды `[набор команд 1]`. Если `[#выражение 1]` неверно, но верно `[#выражение 2]`, выполняются команды `[набор команд 2]`, и т.д. И только если неверны все выражения в текущей конструкции условия, выполнятся команды после `else`.

Как вы понимаете, верность выражения `[#выражение 1]` не исключает верности выражения `[#выражение 2]`, однако верность выражения `[#выражение 2]` исключает верность выражения `[#выражение 1]`. Поэтому я и назвал эту конструкцию конструкцией последовательно-исключающих условий.

Примеры:

```qsp
IF ОЧКИ>124:
	GOTO 'КОН3'
ELSEIF ОЧКИ>99:
	GOTO 'КОН4'
ELSE
	GOTO 'КОН5'
END
```

```qsp
if money mod 10=1 and money mod 100<>11:
	*pl "У вас <<money>> монета."
elseif money mod 10>1 and money mod 10<5 and (money mod 100<5 or money mod 100>20):
	*pl "У вас <<money>> монеты."
elseif money mod 10=0 or money mod 10>4 or (money mod 100>10 and money mod 100<21):
	*pl "У вас <<money>> монет."
end
```

Обратите внимание. Ключевым словом `end` заканчивается не каждый отдельный `elseif`, а вся конструкция условия.

Для многострочных форм записи допускается вложенность неограниченной глубины. Каждый уровень вложения должен заканчиваться своей строкой `end`.

Примеры:

```qsp
if a+b<3 or y=8:
	p 'A+B<3 или Y=8'
	nl 
	if j=88: nl & p 'NEXT' 
	if $h='ooo':
		p 'loo' & jump 'lll'
	end
end
```

```qsp 
if a=0:
	'abc1234'
	if b=0: '0' else '1'
	if j=88: nl & p 'NEXT'
	if $h='ooo':
		p 'loo' & jump 'lll'
	else
		p 'sample text'
		v=8
	end
	1234
else
	'01234'
	g=78
end
```

Несколько примеров неверной записи:

```qsp {4}
! в этом случае, если условие не будет выполнено,
! плеер проигнорирует только команду `k1=34`
! поскольку посчитает, что это однострочное условие
if abcd=3: k1=34
	k2=35 & ! эта команда будет выполняться всегда
	k3=36 & ! эта комнада будет выполняться всегда
end & ! этот end будет проигнорирован
```

```qsp {3,9}
! данная строка выведет ошибку неизвестное действие
! так как однострочные формы записи не должны оканчиваться end`ом
if abcd=3: k1=34 else k1=25 end

! данная запись приведёт к ошибке:
! "Неверная запись однострочного оператора"
if absd=3:
	k=34
else if absd=6:
	k1=25
end
```

## INCLIB
<!-- [:faq_80_02_addqst] -->

`INCLIB` — из заданного файла игры добавляет все локации, названия которых отсутствуют среди текущих игровых локаций. Загруженные локации полностью эквивалентны локациям из основного файла игры. Общая запись:
```qsp		
INCLIB [$путь к файлу игры]
```

Пример:
```qsp
inclib "lib/easy.math.qsp"
inclib "lib/easy.title.qsp"
inclib "res/drive.qsp"
inclib "res/base.qsp"
inclib "res/intro.qsp"
```

:::note
В более старых версиях плееров команда называлась `addqst` и `addlib`.
:::
## JUMP
<!-- [:faq_80_02_jump] -->

`JUMP` — переход в текущем блоке кода на указанную метку. Общая запись:
```qsp
JUMP [$метка]
```
, где `[$метка]` — это метка ниже или выше по коду (см. раздел ["Метки"](#faq_80_05_marks)).

`jump` находит метку только в пределах текущего блока кода, то есть метки локальны.

Отдельными блоками кода в QSP являются:
* код "Выполнить при посещении" конкретной локации (каждая локация - отдельный блок кода),
* код действия даже если действие добавлено программно,
* код в гиперссылке,
* код `DYNAMIC`/`DYNEVAL`

Пример:
```qsp
jump 'КонеЦ'
p 'Это сообщение не будет выведено'
:конец
p 'А это сообщение пользователь увидит'
```

:::note[5.7.0]
С помощью оператора `jump` в старых версиях плеера можно было организовывать циклы:
```qsp
:loop
if s<9:
	s=s+1
	pl s
	jump 'loop'
end
p 'Всё!'
```

Двойной цикл с одной меткой:

```qsp
:loop
if y<9:
	if x<9:
		*p "<<x>> - "
		x=x+1
		jump 'loop'
	end
	*pl ":<<y>>"
	y=y+1
	x=0
	jump 'loop'
end
```

Начиная с версии 5.8.0 для циклов введён собственный оператор `loop`.
:::

## KILLALL
<!-- [:faq_80_02_killall] -->

`KILLALL` — уничтожает все переменные и удаляет все предметы из окна предметов. Эквивалентен конструкции:

```qsp
killvar & killobj
```

:::warning[Внимание!]
Следует помнить, что `killall` не эквивалентен конструкции:

```qsp
killobj & killvar
```

поскольку в этом случае значения переменных удаляются после удаления предметов, а значит код локации-обработчика удаления предметов успевает выполниться (см. `$onobjdel`).
:::

Обычно `killall` используют в начале игры, если в конце игры предусмотрено действие "Начать заново".

## KILLOBJ
<!-- [:faq_80_02_killobj] -->

`KILLOBJ` — удаление предмета, расположенного в заданной позиции. Общая запись:

```qsp
KILLOBJ [#номер]
```

, где `[#номер]` — номер предмета в окне инвентаря. Нумерация предметов начинается с 1. Если параметр `[#номер]` не указан, удаляются все предметы. При удалении каждого предмета с помощью `killobj`, происходит выполнение кода локации-обработчика удаления предметов (см. `$onobjdel`).

Пример:

```qsp
! удаляем самый верхний предмет в списке
killobj 1
! удаляем самый нижний предмет в списке
killobj countobj
! удаляем все предметы
killobj
```

## FREELIB
<!-- [:faq_80_02_killqst] -->

`FREELIB` — удаляет все локации, добавленные с помощью оператора `inclib`.

:::note[5.7.0]
В старых версиях плеера команда называлась `dellib` и `killqst`.
:::
## KILLVAR
<!-- [:faq_80_02_killvar] -->

`KILLVAR` — удаление указанного элемента массива. Общая запись:

```qsp
KILLVAR [$название массива], [индекс элемента]
```

, где `[$название массива]` — название массива, из которого хотим удалить элемент, а `[индекс элемента]` — номер, текстовый индекс, или многомерный индекс элемента в массиве, который хотим удалить. Нумерация элементов массивов начинается с 0.

Если индекс элемента не указан, то очищается весь массив. Если оператор вызван без аргументов, то удаляются все переменные и массивы.

Примеры:

```qsp
killvar 'a', 3 & ! удалит из массива 'a' элемент с индексом 3.
killvar 'unit', 'Десантник' & ! удаляет из массива элемент с индексом 'Десантник'
killvar 'a' & ! удаляет массив 'a'
killvar & ! удаляет все переменные, массивы
killvar '$map_cell', (3, 4) & ! удаление по многомерному индексу
``` 

При удалении элемента все следующие за ним элементы сдвигаются на позицию вверх.

Пример:

```qsp
a[0] = 4
a[1] = 3
a[2] = 23
a[3] = 15
KILLVAR 'a', 1
! теперь массив выглядит так:
! a[0] = 4
! a[1] = 23
! a[2] = 15
```

## LET
<!-- [:faq_80_02_let] -->

`LET` — устаревший оператор для установки значения переменной. Общая запись:

```qsp
LET [название переменной] = [выражение]
```

, где `[название переменной]` — это допустимое имя переменной, `[выражение]` — это допустимое для данной переменной значение.

Названия числовых переменных записываются без символа `$` в начале. Названия текстовых переменных записываются с символом `$` в начале. Примеры:

```qsp
! задаём текстовую переменную
let $text="text string"
! задаём числовую переменную
let abs=123
```

Данный оператор является устаревшим, как и оператор `set`, поскольку в настоящее время значение переменной устанавливается через присвоение:

```qsp
$text = "text string"
```

Использование операторов `set` и `let` не рекомендуется.

## MENU
<!-- [:faq_80_02_menu] -->

`MENU` — в любом месте игры выводит на экран всплывающее меню, пункты которого прописаны в указанном массиве. Общая запись:

```qsp
MENU [$название массива]
```

Прежде, чем использовать данный оператор, необходимо заполнить массив, на основе содержимого которого будут формироваться пункты меню. Пункты меню — это строковые начения массива с особым форматом записи:

```qsp
"название пункта меню:название локации:путь к файлу иконки"
```

Название пункта меню — это то, что мы увидим на экране, когда меню будет выведено; название локации — это название локации, код которой будет выполняться при щелчке на соответствующем пункте меню; путь к файлу иконки — это путь к файлу изображения, которое будет выведено рядом с названием пункта меню.

Таким образом мы можем заполнить массив для того, чтоб создать наши пункты меню:

```qsp
$stone[0] = 'Взять камень:takestone'
$stone[1] = 'Кинуть камень:throwstone'
$stone[2] = 'Осмотреть камень:lookstone'
```

Поиск символов ":" начинается с конца строки, то есть название пункта меню может содержать двоеточия, однако тогда обязательно после названия локации должно стоять двоеточие, даже если вы не используете иконки для пунктов меню.

Если путь к файлу иконки не указан или указанный файл недоступен, то пункт меню отобразится без иконки.

Здесь название массива (`$stone`) - это название меню, а текстовые значения массива - действия, для которых указаны названия и названия локаций-обработчиков выбора пунктов меню. При выборе пункта "Взять камень" произойдёт обработка локации с названием "takestone". Аналогично будет происходить с другими пунктами.

Чтобы вызвать меню на экран нужно воспользоваться оператором menu:

```qsp
menu '$stone'
```

Меню можно вызывать в любом месте игры, например, из гиперссылок:

```qsp
'<a href="EXEC: menu `$stone`">Камень</a>'
```

В локацию-обработчик выбора пункта меню передаётся аргумент (`args[0]`) - позиция выбранного пункта. Позиции элементов меню нумеруются с 1.

Пример создания меню с иконками:

```qsp
! нет иконки
$usr_menu[0] = 'Взять предмет:take_item'
! иконка задана gif-файлом
$usr_menu[1] = 'Положить предмет:put_item:images/put_item.gif'
! иконка задана значением $icon_file
$usr_menu[2] = 'Осмотреть предмет:look_item:<<$icon_file>>'
! пункт меню задан 3-мя переменными
$usr_menu[3] = '<<$name>>:<<$location>>:<<$file>>'
 
menu 'usr_menu' &! покажет меню из 4-х пунктов
```

Меню заканчивается на элементе массива со значением `''` (пустая строка). Т.е. если массив меню состоит из элементов 'Взять', 'Осмотреть', 'Бросить', то 2 последних пункта меню не будут созданы:

```qsp
$usr_menu[0] = 'Взять предмет:take_item' & ! этот пункт мы увидим на экране
$usr_menu[1] = 'Осмотреть предмет:look_item' & ! и этот пункт мы увидим на экране
$usr_menu[2] = '' & ! здесь пустое значение, плеер посчитает, что меню кончилось
$usr_menu[3] = 'Положить предмет:put_item' & ! этот пункт мы не увидим
```

Чтобы вставить разделитель в меню, вместо соответствующего элемента массива напишите `"-:-"`. Т.е. если нужно поставить разделитель вместо 3-го элемента:

```qsp
$usr_menu[0] = 'Взять предмет:take_item'
$usr_menu[1] = 'Осмотреть предмет:look_item'
$usr_menu[2] = '-:-'
$usr_menu[3] = 'Положить предмет:put_item'
```

## MSG
<!-- [:faq_80_02_msg] -->

`MSG` — вывод указанного сообщения в диалоговом окне. Общая запись:

```qsp
MSG [сообщение]
```

, где `[сообщение]` — любая строка текста. число, выражение любого типа. Примеры:

Примеры:

```qsp
! простой вывод сообщения.
msg 'Много спелых груш.'
! получим окно с сообщением 'Много спелых груш'
```

```qsp			 
! Пример сообщения в действии ACT.
act 'Поесть груш':
   msg 'Ммм груши очень вкусные.'
end
! Получим вывод сообщения при клике по действию "Поесть груш"
```

```qsp			 
!Пример с условием.
if hlebgotov = 1:
	msg 'Похоже хлеб уже готов.'
end
! Получаем вывод сообщения когда условие hlebgotov = 1
```

## NL
<!-- [:faq_80_02_nl] -->

`NL` — переход на новую строку, затем вывод текста в окне основногодополнительного описания. Общая запись:
```qsp
NL [$текст]
```
, где `[$текст]` — любая строка текста, число, или выражение любого типа. Если `[$текст]` отсутствует, происходит просто переход на новую строку. Пример:
```qsp
p "Текст без перехода на новую строку."
nl "Переход на новую строку + выведение текста."
p "Текст без перехода на новую строку."
```

## OPENGAME
<!-- [:faq_80_02_opengame] -->

`OPENGAME` — загрузка указанного файла состояния игры. Общая запись:
```qsp
OPENGAME [$путь]
```
, где `[$путь]` — путь к файлу сохранённого состояния игры. Если параметр `[$путь]` отсутствует, то вызывается окно загрузки состояния игры.

Пример:
```qsp
! загрузка состояния из файла 1.sav
opengame "1.sav"
! открываем окно загрузки состояния
opengame
```
См. также локацию-обработчик события загрузки состояния игры ([$ongload](#faq_80_04_ongload)).

## OPENQST
<!-- [:faq_80_02_openqst] -->

`OPENQST` — открытие и запуск указанного файла игры. Общая запись:
```qsp
OPENQST [$путь]
```
, где [$путь] — путь к файлу игры, который требуется запустить. Пример:
```qsp
openqst "gamespool/cubesgame.qsp"
```
При использовании данного оператора, не происходит удаления переменных, удаления предметов инвентаря, очистки дополнительного описания и строки ввода, а также остановки проигрываемых файлов. Если вам нужно очистить экран и значения всех переменных, можно прописать в начале загружаемого файла игры такие команды:
```qsp
killall & cls & close all
```

## P
<!-- [:faq_80_02_p] -->

`P` — вывод текста в окно основного описания без перехода на новую строку. Вывод текста любым другим оператором сразу после p добавит новый текст сразу после текущего. Общая запись:
```qsp
P [$текст]
```
, где `[$текст]` — любая строка текста, число, или выражение любого типа. `[$текст]` может быть пустой строкой '', но не должен отсутствовать. Пример:
```qsp
p "Текст без перехода на новую строку."
p "Текст без перехода на новую строку."
p ""
p "Текст без перехода на новую строку."
```

## PL
<!-- [:faq_80_02_pl] -->

`PL` — вывод текста в окно основного описания, затем переход на новую строку. Общая запись:
```qsp
PL [$текст]
```
, где `[$текст]` — любая строка текста, число, или выражение любого типа. `[$текст]` может отсутствовать, тогда просто переход на новую строку. Пример:
```qsp
pl "Вывод текста, затем переход на новую строку."
pl "Вывод текста, затем переход на новую строку."
p "Текст без перехода на новую строку."
pl "Вывод текста, затем переход на новую строку."
```

## PLAY
<!-- [:faq_80_02_play] -->

`PLAY` — проигрывание указанного звукового файла с заданной громкостью. Общая запись:
```qsp
PLAY [$путь к звуковому файлу],[#громкость]
```
, где `[$путь к звуковому файлу]` — путь к звуковому файлу относительно файла игры, `[#громкость]` — громкость воспроизведения в процентах от 0 до 100. Параметр `[#громкость]` может отсутствовать, при этом громкость принимается равной 100%. Примеры:
```qsp
!Громкость 100%
play 'sound/music.mp3'
!Громкость 50%
play 'sound/music.mp3',50
!Громкость 0% (без звука)
play 'sound/music.mp3',0
```

```qsp		 
!Проигрывание файла по адресу из переменной $file
! с расширением 'mid'
! и громкостью volume
$file="melody"
play '<<$file>>.mid',volume
! аналогично:
$file="melody.mid"
play $file,volume
```
Если файл уже проигрывается, то изменяется громкость звучания без его "перезапуска". Поддерживается множество различных аудиоформатов и одновременное звучание до 32-х композиций.

## REFINT
<!-- [:faq_80_02_refint] -->

`REFINT` — принудительное обновление интерфейса (в т.ч. смена цветов, шрифтов, назначенных с помощью системных переменных).

По умолчанию обновление интерфейса происходит 2 раза в секунду (каждые 500 мс). Так же см. оператор settimer.

## SAVEGAME
<!-- [:faq_80_02_savegame] -->

`SAVEGAME` — сохранение состояния игры в указанный файл. Общая запись:
```qsp
SAVEGAME [$путь]
```
, где `[$путь]` — путь к создаваемому файлу сохранения состояния игры. Если параметр `[$путь]` отсутствует, то вызывается окно сохранения состояния игры.

Пример:
```qsp
! сохранение состояния в файл 1.sav
savegame "1.sav"
! открываем окно сохранения состояния
savegame
```
См. также [локацию-обработчик события сохранения состояния игры ($ongsave)](#faq_80_04_ongsave).

## SET
<!-- [:faq_80_02_set] -->

`SET` — устаревший оператор для установки значения переменной. Общая запись:
```qsp
SET [название переменной]=[выражение]
```
, где `[название переменной]` — это допустимое имя переменной, `[выражение]` — это допустимое для данной переменной значение.

Названия числовых переменных записываются без символа `$` в начале. Названия текстовых переменных записываются с символом `$` в начале. Примеры:
```qsp
! задаём текстовую переменную
set $text="text string"
! задаём числовую переменную
set abs=123
```
Данный оператор является устаревшим, как и оператор `let`, поскольку в настоящее время значение переменной устанавливается через присвоение:
```qsp
$text="text string"
```
Использование операторов `set` и `let` не рекомендуется, так как они устарели.

## SETTIMER
<!-- [:faq_80_02_settimer] -->

`SETTIMER` — задаёт интервал обращения к локации-счётчику. Общая запись:
```qsp
SETTIMER [#выражение]
```
, где `[#выражение]` — период обращения к локации-счётчику в миллисекундах. По умолчанию плеер обращается к локации-счётчику каждые 500 мс., т.е. 2 раза в секунду.

Установка периода обращения к локации-счётчику влияет и на частоту автоматического обновления настроек интерфейса.

Примеры:
```qsp
! локация-счётчик будет запускаться каждые 2 секунды:
settimer 2000
```

```qsp
! локация-счётчик будет запускаться 4 раза в секунду:
settimer 250
```

```qsp
! если мы задаём частоту обращения (раз в секунду)
frequency=10 & ! десять раз в секунду
settimer 1000/frequency
```

```qsp
! если мы задаём период обращения (через сколько секунд)
period=2 & ! каждые две секунды
settimer 1000*period
```
Минимальное значение периода таким образом может быть 1 миллисекунда:
```qsp
settimer 1
```
Однако на практике минимальное значение ограничено мощностью вашего компьютера, и оно, как правило, выше 1 миллисекунды.

## SHOWACTS
<!-- [:faq_80_02_showacts] -->

`SHOWACTS` — управляет отображением окна действий на экране. Общая запись:
```qsp
SHOWACTS [#выражение]
```
, где `[#выражение]` — это число. Обычно используются значения 0 и 1. Если значение выражения `[#выражение]` отлично от нуля, окно действий отображается. Если значение выражения `[#выражение]` равно нулю, окно действий скрыто. Примеры:
```qsp
showacts 1 & ! показывает список действий
showacts 0 & ! скрывает список действий
```
Для удобства чтения кода можно заранее определить переменные on и off и использовать их:
```qsp
on=1
off=0
showacts on & ! показывает список действий
showacts off & ! скрывает список действий
```

## SHOWINPUT
<!-- [:faq_80_02_showinput] -->

`SHOWINPUT` — управляет отображением строки ввода на экране. Общая запись:
```qsp
SHOWINPUT [#выражение]
```
, где `[#выражение]` — это число. Обычно используются значения 0 и 1. Если значение выражения `[#выражение]` отлично от нуля, строка ввода отображается. Если значение выражения `[#выражение]` равно нулю, строка ввода скрыта. Примеры:
```qsp
showinput 1 & ! показывает строку ввода
showinput 0 & ! скрывает строку ввода
```
Для удобства чтения кода можно заранее определить переменные on и off и использовать их:
```qsp
on=1
off=0
showinput on & ! показывает строку ввода
showinput off & ! скрывает строку ввода
```

## SHOWOBJS
<!-- [:faq_80_02_showobjs] -->

`SHOWOBJS` — управляет отображением инвентаря на экране. Общая запись:
```qsp
SHOWOBJS [#выражение]
```
, где `[#выражение]` — это число. Обычно используются значения 0 и 1. Если значение выражения `[#выражение]` отлично от нуля, инвентарь отображается. Если значение выражения `[#выражение]` равно нулю, инвентарь скрыт. Примеры:
```qsp
showobjs 1 & ! показывает инвентарь
showobjs 0 & ! скрывает инвентарь
```
Для удобства чтения кода можно заранее определить переменные `on` и `off` и использовать их:
```qsp
on=1
off=0
showobjs on & ! показывает инвентарь
showobjs off & ! скрывает инвентарь
```

## SHOWSTAT
<!-- [:faq_80_02_showstat] -->

`SHOWSTAT` — управляет отображением окна дополнительного описания на экране. Общая запись:
```qsp
SHOWSTAT [#выражение]
```
, где `[#выражение]` — это число. Обычно используются значения 0 и 1. Если значение выражения `[#выражение]` отлично от нуля, окно дополнительного описания отображается. Если значение выражения `[#выражение]` равно нулю, окно дополнительного описания скрыто. Примеры:
```qsp
showstat 1 & ! показывает окно дополнительного описания
showstat 0 & ! скрывает окно дополнительного описания
```
Для удобства чтения кода можно заранее определить переменные `on` и `off` и использовать их:
```qsp
on=1
off=0
showstat on & ! показывает окно дополнительного описания
showstat off & ! скрывает окно дополнительного описания
```

## UNSELECT
<!-- [:faq_80_02_unsel] -->

`UNSELECT` — отмена выделения предмета. Имеет краткую форму `unsel`.

При щелчке играющим по какому-либо предмету, он остаётся выделенным. Чтобы снять выделение с предмета используется данный оператор. Обычно его размещают на локации-обработчике выделения предмета.
```qsp
if $selobj='Апельсин':
	*P 'Вкусный сладкий апельсин. Много нас, а он один.'
end
if $selobj = 'Чайник':
	p 'Самый обычный чугунный чайник.'
end
...
if $selobj='Отвёртка':
	menu '$screwdriver'
end
unsel
```

## VIEW
<!-- [:faq_80_02_view] -->

`VIEW` — выводит на экран указанное изображение. В классическом плеере изображение выводится в отдельном окошке (окно предпросмотра), в AeroQSP и Quest Navigator изображение выводится верхним слоем в общем окне. Общая запись:
```qsp
VIEW [$путь к графическому файлу]
```
, где `[$путь к графическому файлу]` — путь к файлу картинки. Если параметр `[$путь к графическому файлу]` отсутствует, или задан как `''` (пустая строка), окно предпросмотра закрывается.

Примеры:
```qsp
! выводим изображение в окне предпросмотра
view 'content/monster.png'
! закрываем окно предпросмотра
view ''

! закрыть окно предпросмотра можно и так
view
```

## WAIT
<!-- [:faq_80_02_wait] -->

`WAIT` — приостановка выполнения кода программы на указанное количество миллисекунд. Общая запись:
```qsp
WAIT [#миллисекунды]
```
, где `[#миллисекунды]` — время в миллисекундах, на какое следует остановить выполнение кода программы.

Пример:
```qsp
! остановка выполнения программы на 5 секунд
wait 5000
```
Использовать данный оператор необходимо с осторожностью, поскольку приостановка выполнения кода блокирует для игрока возможность взаимодействовать с игрой.
`WAIT` не только прерывает выполнение кода, но так же засталяет плеер выводить на экран информацию из буфера экрана. При нормальном выполнении кода локации, весь текст для операторов `*pl *p` pl nl и т.д. помещается в специальный буфер экрана, и уже после выполнения всего кода на локации выводится на экран. При использовании `WAIT` текст из буфера выводится сразу в момент выполнения `WAIT`, что иногда полезно, поскольку позволяет проследить изменение некоторых значений поэтапно.

В примере ниже числа сначала запишутся в буфер экрана и только потом появятся на экране:
```qsp
loop i=0 while i<5 step i+=1:
	*p i
end
*pl
```

В следующем примере
## XGOTO
<!-- [:faq_80_02_xgoto] -->

`XGOTO` — переход на указанную локацию без очистки окна основного описания. Общая запись:
```qsp
XGOTO [$локация],[аргумент 0],[аргумент 1], ... ,[аргумент 8]
```
, где `[$локация]` — название локации, на которую должен быть осуществлён переход. Аргументы `[аргумент 0]`, `[аргумент 1]` и т.д. могут использоваться на этой локации, их значения автоматически помещаются в переменные `args[0]`, `args[1]`, и т.д. соответственно. Использование аргументов не обязательно.

При переходе на новую локацию при помощи `xgoto` не очищается окно основного описания, а базовое описание новой локации добавляется к уже имеющемуся тексту в окне основного описания. Список действий очищается, затем в окно действий выводятся базовые действия, а так же выполняется код из поля "Выполнить при посещении" локации `[$локация]`. Так же при переходе на новую локацию изменяется значение, возвращаемое функцией `$curloc`.

Примеры:
```qsp
! переход на локацию "дом".
! Массив args на локации "дом" будет пуст.
xgoto 'дом'
```

```qsp
! переход на локацию "улица" с передачей 2-х параметров.
! на локации "улица" args[0] равен 1,
! $args[1] содержит строку "данные".
xgoto 'улица',1,'данные'
```
Оператор имеет краткую форму xgt:
```qsp
XGT [$локация],[аргумент 0],[аргумент 1], ... ,[аргумент 8]
```
