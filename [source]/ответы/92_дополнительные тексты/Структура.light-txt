==Структура==

Необходимо структурировать проект книги, чтобы обеспечить автоматическое конвертирование в fb2 или html. Вообще нам нужно конвертировать именно в fb2, а fb2 уже потом можно конвертировать в HTML. Так что в первую очередь необходимо проработать конвертирование в fb2.

В fb2 документ разбивается на секции, и вся трудность преобразования из текстового формата в fb2 заключается в том, чтобы правильно разбить документ на секции.

В первую очередь документ разбивается на секции по папкам. То есть если у нас в проекте четыре папки на верхнем уровне, эти четыре папки образуют четыре секции верхнего уровня.

Далее идёт анализ содержимого папок.

Во-первых, каждый новый заголовок первого уровня, найденный в такой папке, будет создавать новую секцию на том же уровне вложенности.
Во-вторых, записанный отдельной строкой [:identifikator] является идентификатором секции. Если подобный идентификатор записан не отдельной строкой, а в начале строки, этот идентификатор будет относиться к абзацу, который данная строка олицетворяет. В fb2 каждая отдельная строка является абзацем.
В-третьих, по правилам fb2 секция не может содержать одновременно и параграфы и секции, поэтому если в секции будет встречен заголовок второго или более низкого уровня, это автоматически заключит предыдущие набранные строки в секцию условно второго уровня, и так же будет создана новая секция на том же условном втором уровне.
В-четвёртых, полностью исключаются все части строк и строки, являющиеся комментариями типа /* комментарий */
В-пятых, заголовки шестого уровня в fb2 распознаются как подзаголовки.

Исключения:
	
	Можно исключить заголовки любых уровней из тривиального подсчёта вложенности, поместив часть текста, относящуюся к этому заголовку в теги <section_of_head> </section_of_head>. Данные теги искусственно создают новую вложенную секцию, в которой уже заголовки парсятся, как начала новых секций. Так же это исключает обработку заголовков шестого уровня, как подзаголовков. Они тоже парсятся, как начала новых секций.
	Можно исключить обработку комментариев, поместив их между меток блока кода. Такой комментарий обязательно будет выведен.

=Объект Секция=

Имеет атрибуты:
	* идентификатор секции — section_id
	* заголовок секции — section_title
	* тело секции — section_body:
		Тело секции представляет собой список, который может включать что-то одно:
			* Либо строки
			* Либо секции более низкого уровня

=Структурные элементы=

-Термины-

Термины обязательно облекаются в ``, их можно перечислять через запятую, внутри можно размещать иное форматирование, например гиперссылки, или айди. После перечисленных терминов обязательно ставится тире.
Пример:

`Термин`, `[Синоним](#link внутри раздела)` — определение следует сразу за тире.


=Типы секций при конвертации HTML=

h1
h2
h3
h4
h5
h6
section_of_head
id
ul
ol
code-block
quote-block

=Конвертирование в HTML=

--Общие функции--

dirList(folder_path) - функция возвращает списки файлов (только с расширением .txt-light) и папок в указанной папке.
randomString(length) - функция возвращает строку случайных символов указанной длины.
clearStringList(string_list) - функция возвращает список строк, очищенный от комментариев.
typeString(string) - функция определяет тип строки по содержимому.

--Структурные Объекты и их особенности--

-NewDataBase-

[NewDataBase] - объект базы данных. Условная база, в которой собраны необходимые "глобальные" данные, в т.ч. перечень якорей и файлов в связке.

++Данные:++

/* Здесь path, id_, anchor - условные записи соответственно: абсолютного пути файла, идентификатора файла, якоря. */
.filecount - счётчик файлов. Показывает общее число файлов, внесённых в базу. 0
.curfile - идентификатор текущего файла. То есть файла, с которым мы в настоящее время работаем. ""
.files_dict - словарь, в котором связываем путь файла с идентификатором. files_dict[path]=id_. {}
.anchors_dict - словарь, в котором связываем уникальные якоря и файлы (то есть показываем какой якорь в каком файле присутствует). anchors_dict[anchor]=id_. {}
.addition — добавочная секция в файл. Представляет собой список строк, которые добавляются к каждому файлу в момент генерации/конвертирования. []
.header_list — список строк для верхней части страницы HTML. Добавляется при сборке HTML-страницы ко всем файлам. []
.footer_list - списко строк для нижней части страницы HTML. Добавляется при сборке HTML-страницы ко всем файлам. []
.export_folder_path - путь к папке, в которую будет осуществляться экспорт файлов. ""
.typesOfClass - словарь для связки типов с классами, чтобы не париться, определяя, к какому классу/типу относится тот или иной объект. "folder" - объект класса Папка, "file" - объект класса Файл, "segment" - объект класса Сегмент, "section" - объект класса Секция. {}

++Методы++

.currentFile() - возвращает идентификатор текущего файла (т.е. файла, с которым мы непосредственно сейчас работаем)
.setCurFile(id_) - по идентификатору файла делает его текущим (т.е. файлом, с которым мы в дальнейшем работаем).

.proveAdd() - проверяет, присутствует ли в базе добавочная секция, возвращает True или False.
.getAdd() - получает добавочную секцию из базы.
.addAdd(string_list) — добавляет в базу добавочную секцию. Здесь string_list - список строк.
.delAdd() - удаляет из базы добавочную секцию.

.lastFileID() - возвращает айди последнего добавленного файла. Идентификатор последнего добавленого файла вычиляется из счётчика .filecount. Например, если счётчик равен нулю, значит файлы не были добавлены в базу, таким образом нельзя вычислить айди, и возвращается None. Но если счётчик больше нуля, тогда идентификатор файла вычисляется так: из счётчика вычитается единица, полученное число преобразуется к строке, затем эта строка дополняется слева нулями, чтобы длина строки была равна восьми.
.genNewFileID() - возвращает новый сгенерированный айди на основе счётчика.
.addFile(path) - добавляем новый файл. При этом автоматически генерируется новый айди и в files_dict вносится запись о файле.
.getFileID(path) - возвращет идентификатор файла, путь которого мы указали. Если файл не внесён в базу, возвращает None.
.getFilePath(id_) - возвращает путь к файлу, айди которого мы указали.
.getFileName(anchor) - возвращает идентификатор файла по указанному якорю или значение None. Все якоря уникальны для всего набора файлов.

.addAnchor(anchor) - привязывает якорь к текущему файлу, т.е. к файлу, идентификатор которого прописан в .curfile.

.addHeader(string_list) - добавляет список строк для верхней части страницы HTML в базу.
.addFooter(string_list) - добавляет список строк для нижней части страницы HTML в базу.
.getHeader() - возвращает список строк для верхней части страницы HTML из базы.
.getFooter() - возвращает список строк для нижней части страницы HTML из базы.
.addExportPath(path) - добавляет в базу путь к папке, в которую необходимо поместить результирующие файлы.
.getExportPath() - получает из базы путь к папке, в которую необходимо записать результирующие файлы.

/*
.addClassType(kw,type_) - добавляет связку ключевого слова и типа объекта.
.getClassType(kw) - возвращает тип объекта по указанному ключевому слову, либо None.
.proveClassType(kw) - возвращает True или False в зависимости от того, присутствует ли указанный ключ в словаре связок.
*/

.setContentFile(path) - устанавливает путь (идентификатор) файла, в котором размещено "Содержание" (contents)
.getContentFile() - возвращает путь (идентификатор файла), в котором размещено "Содержание"
.addContent(string_list) - добавляет содержание в базу.
.getContent() - возращает содержание.

-NewFolder-

[NewFolder] - объект класса "Папка" может содержать другие Папки, а так же файлы. Сами Папки на структуру и размещение HTML-документов не влияют.

++Данные++

.path - полный путь к папке, является её идентификатором. ""
.files - список вложенных в папку файлов. []
.folders - список вложенных в папку папок. []

++Методы++

.convert2HTML(base) - вызывает методы .convert2HTML() рекурсивно для всех папок, вложенных в текущую, для файлов происходит генерация физических файлов через вызов метода .buildThis()

-NewFile-

[NewFile] - объект класса файл. Файл состоит из одного (как правило) или большего количества сегментов.

++Данные++

.path - полный путь к файлу, является так же его уникальным идентификатором. ""
.source - исходные строки, полученные из "физического" файла. Именно эти строки после очистки от комментариев передаются в Сегмент.
.segments - список сегментов, включённых в файл. Как правило в файле один сегмент, но теоретически можно включить и больше. []
.HTML - список строк готового HTML-файла. []

++Методы++

.getFileName() - возвращает имя файла с отсечением пути. ""
.convert2HTML(base) - запускает вызов метода .convert2HTML() для всех сегментов, вложенных в файл.
.getHTML(base) - возвращает сконвертированное в HTML содержимое файла из атрибута .HTML.
.buildThis(base) - данный метод собирает готовый HTML-файл из атрибута .HTML.

-NewSegment-

[NewSegment] - у объектов класса Сегмент есть предыстория, из неё будет понятно, почему потребовалось выделить новый класс. Изначально объекты класса Файл разбивались на секции, затем проходила обработка. Поскольку одним из типов секций является section_of_head, пришлось эту секцию сначала преобразовать в подобие файла, потом вновь переразбить на секции, потом работать с секциями уже нормально. Таким образом были созданы два класса Файл (уровень над секциями в иерархии) и КвазиФайл (уровень под секциями в иерархии), работавшие с практически одинаковыми методами. Отличалось только выставление идентификаторов. Фактически, чтобы переписать метод .splitFile() (например, чтобы исправить ошибку), приходилось переписывать его дважды. Наследование эту проблему не решало, поскольку методы для Файла и для Квазифайла отличались. Единственным решением, которое пришло мне на ум, избавиться от квазифайла, а вместо него написать класс, похожий на квазифайл, но который будет находиться ниже в иерархии, чем файл, а у самого файла отнять возможность разбиваться на секции.

++Данные++

.source - список исходных строк, которые затем разбиваются на секции. []
.sections - список секций, составляющих сегмент. Данный список инициализируется, как пустой, и лишь затем заполняется секциями через .segmentSplit(). []
.HTML - список строк готового HTML. []

++Методы++

.segmentSplit() - разбивает сегмент на секции и добавляет секции в .sections. Вызывается автоматически при инициализации.
.addSection(section) - добавляет в объект сформированную секцию.
.getLen() - получает число секций в сегменте. Если сегмент состоит из одной секции, значит дальнейшее преобразование невозможно. Это полезно, например, если мы вкладываем одну секцию в другую.
.convert2HTML(base) - dspsdftn конвертирование всех секций в сегменте в HTML, а затем получение HTML-строк в атрибут HTML.
.getHTML(base) - возвращает HTML-содержимое сегмента.

-NewSection-

[NewSection] - объект класса Секция. Секции генерируются автоматически в процессе .segmentSplit() и их границы вычисляются по первичному форматированию. Секции могут состоять из строк и сегментов.

++Типы секций++

"section_of_head" - секция заголовков (правильнее назвать "секция с заголовками"). Иногда не хватает шести уровней заголовков, тогда приходится прибегать к такому трюку. Выделяем отдельный контейнер внутри файла, и в этом контейнере нумеруем уровни заголовков вновь начиная с первого. Вот таким контейнером по сути и является подобная секция. Данная секция всегда преобразуется в один отдельный сегмент, который впоследствии снова обрабатывается, и разбивается на секции.
"h1","h2","h3","h4","h5","h6" - заголовки. На шесть уровней заголовков приходится шесть типов секций. Технически столько не нужно, но это осталось от конвертера fb2, пока я не хочу убирать.
"ul", "ol" - соответственно секции маркированного и нумерованного списков. Опять таки тип секции не играет роли, списки всё равно дробятся потом автоматически, но решено было оставить пока что.
"code-block" - секция кода. Внутри секции кода нельзя размещать иные секции, именно этим он и удобен иногда. Код внутри секции кода должен автоматически расцвечиваться при получении HTML-разметки.
"quote-block" - секция цитаты. Внутри секции цитаты допустимо размещать иные секции, поэтому как правило, данную секцию выделяют в сегмент и разбивают повторно.
"" - пустой тип. Секция параграфов.

++Данные++

.type - тип секции. "".
.id - идентификатор секции. "". Назначается если секция является заголовком.
.source - список отднотипных строк или сегментов. []
.HTML - список строк готового HTML. []

++Методы++

.getLen() - получает число строк/сегментов секции. То есть длину .source.

.changeType(string) - изменяет тип секции на указанный.
.changeID(string) - изменяет идентификатор секции на указанный (для заголовков).

.getType() - получает тип секции.
.getID() - получает идентификатор секции (для заголовков).

.addString(string) - добавляет строку в исходник секции.

--Прилагательные объекты--

-NewString-

[NewString] - это объект класса Строка, который может состоять либо из исходной строки, либо из вложенных подстрок. Данный объект необходим, чтобы рекурсивно рассматривать различные элементы строки текста и таким образом отыскивать элеметны, конвертируемые в HTML.

Типы Строк:

"" - стандартная строка узлового типа. Эти строки могут быть как корневыми, так и конечными в зависимости от содержимого. Если в такой строке не обнаруживается вложенное содержимое, парсинг строки останавливается. Если же обнаруживается, строка разбивается на подстроки вновь и анализируются уже вложенные строки.
"string" — данный вид строки может быть проанализирован и разбит на иные объекты-Строки. Именно строки такого типа могут опознаваться, как содержащие термины.
"term" — данный тип строки указывает, что мы имеем дело с термином, однако содержимое этой строки повторно анализируется как стандартная строка узлового типа, поскольку даже сам термин может содержать иные элементы форматирования.

