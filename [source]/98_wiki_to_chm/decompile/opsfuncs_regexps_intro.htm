<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
   <title>Введение в регулярные выражения</title>
   <meta name="generator" content="Help &amp; Manual" />
   <meta name="keywords" content="" />
   <meta http-equiv="Content-Type" content="text/html; charset=Windows-1251" />
   <meta http-equiv="Content-Style-Type" content="text/css" />
   <link type="text/css" href="default.css" rel="stylesheet" />

<script type="text/javascript" src="helpman_topicinit.js"></script>
</head>
<body style="margin: 0px 0px 0px 0px; background: #FFFFFF;">


<table width="100%" border="0" cellspacing="0" cellpadding="5" bgcolor="#808080">
  <tr valign="middle">
    <td align="left">
      <p class="p_Heading1"><span class="f_Heading1">Введение в регулярные выражения</span></p>

    </td>
    <td align="right">
     <span style="font-size: 9pt">
     <a href="about.htm">Top</a>&nbsp;
     <a href="opsfuncs_regexps.htm">Previous</a>&nbsp;
     <a href="tips.htm">Next</a>
     </span>
    </td>
  </tr>
</table>


<!-- Placeholder for topic body. -->
<table width="100%" border="0" cellspacing="0" cellpadding="5"><tr valign="top"><td align="left">
<p><span style="font-weight: bold;">Введение</span></p>
<p>&nbsp;</p>
<p>QSP отличается наличием очень мощных и гибких механизмов для работы с двумя самыми часто используемыми типами данных: строками и массивами. Однако в QSP есть ещё один механизм обработки строк, который, ввиду своей сложности, был пропущен мною. Я говорю о механизме регулярных выражений (regular expressions). Настало время поговорить о них, потому что в дальнейшем нам, возможно, очень часто потребуется использовать их. Кроме того, использование регулярных выражений во многих ситуациях поможет вам заменить кучу кода всего одной строчкой. Единственная проблема, которая обычно возникает при работе с регулярными выражениями - их очень необычный, и, поначалу, совершенно непонятный <a href="dict.htm#syntax">синтаксис</a>. Поэтому я постараюсь рассказать о синтаксисе регулярных выражений по возможности более просто и подробно.</p>
<p>&nbsp;</p>
<p><span style="font-weight: bold;">Общая информация</span></p>
<p>&nbsp;</p>
<p>Регулярное выражение (regular expression, regexp, регэксп) - механизм, позволяющий задать шаблон для строки и осуществить поиск данных, соответствующих этому шаблону в заданном тексте. </p>
<p>Кроме того, дополнительные функции по работе с regexp'ами позволяют получить найденные данные в виде массива строк, произвести замену в тексте по шаблону, разбиение строки по шаблону и т.п. Однако главной их функцией, на которой основаны все остальные, является именно функция поиска в тексте данных, соответствующих шаблону, описанному в синтаксисе регулярных выражений.</p>
<p>Очень часто регулярные выражения используются для того, чтобы проверить, является ли данная строка строкой в необходимом формате. Например, следующий regexp предназначен для проверки того, что строка содержит корректный e-mail адрес:</p>
<p>&nbsp;</p>
<p>^\w+([\.\w]+)*\w@\w((\.\w)*\w+)*\.\w{2,3}$</p>
<p>&nbsp;</p>
<p>Выглядит, на первый взгляд, довольно страшно :-) Но, тем не менее, это работает, и работает очень хорошо. А когда вы научитесь писать и использовать regexp'ы в своем коде - это ещё будет и сильно облегчать вам жизнь.</p>
<p>&nbsp;</p>
<p>Регулярные выражения пришли к нам из Unix и Perl. Кстати, необходимо заметить, что полное описание синтаксиса регулярных выражений занимает более 50 килобайт, и, естественно, здесь мы не будем рассматривать весь синтаксис. Нам необходимы только основы, которые помогут вам понять, как именно пишутся регулярные выражения.</p>
<p>Сутью механизма регулярных выражений является то, что они позволяют задать шаблон для <span style="font-weight: bold;">нечеткого</span> поиска по тексту. Например, если перед вами стоит задача найти в тексте определённое слово, то с этой задачей хорошо справляются и обычные функции работы со строками. Однако если вам нужно найти &quot;то, не знаю что&quot;, о чем вы можете сказать только то, как <span style="font-weight: bold;">приблизительно</span> это должно выглядеть - то здесь без регулярных выражений просто не обойтись. Например, вам необходимо найти в тексте информацию, про которую вам известно только то, что это &quot;3 или 4 цифры, после которых через пробел идёт 5 заглавных латинских букв&quot;, то вы сможете сделать это очень просто, воспользовавшись следующим регулярным выражением:</p>
<p>&nbsp;</p>
<p>\d{3,4}\s[A-Z]{5}</p>
<p>&nbsp;</p>
<p><span style="font-weight: bold;">Синтаксис регулярных выражений</span></p>
<p>&nbsp;</p>
<p>Основой синтаксиса регулярных выражений является тот факт, что некоторые символы, встречающиеся в строке, рассматриваются не как обычные символы, а как имеющие специальное значение (т.н. <span style="font-weight: bold;">метасимволы</span>). Именно это решение позволяет работать всему механизму регулярных выражений. Каждый метасимвол имеет свою собственную роль в синтаксисе регулярных выражений. Далее мы рассмотрим все эти метасимволы.</p>
<p>Одним из самых важных метасимволов является символ обратного слэша (&quot;<span style="font-weight: bold;">\</span>&quot;). Если в строке встречается этот символ, то парсер рассматривает символ, непосредственно следующий за ним, двояко:</p>
<p>Если следующий символ в обычном режиме имеет какое-либо специальное значение, то он теряет это свое специальное значение и рассматривается как обычный символ. Это совершенно необходимо для того, чтобы иметь возможность вставлять в строку специальные символы, как обычные. Например, метасимвол &quot;<span style="font-weight: bold;">.</span>&quot; в обычном режиме означает &quot;любой единичный символ&quot;, а &quot;\.&quot; означает просто точку. Также можно лишить специального значения и сам этот символ: &quot;\\&quot;.</p>
<p>Если следующий символ в обычном режиме не имеет никакого специального значения, то он может получить такое значение, будучи соединённым с символом &quot;<span style="font-weight: bold;">\</span>&quot;. К примеру символ &quot;d&quot; в обычном режиме воспринимается просто как буква, однако, будучи соединённой с обратным слэшем (&quot;\d&quot;) становится метасимволом, означающим &quot;любая цифра&quot;.</p>
<p>Существует множество символов, которые образуют метасимволы в паре с обратным слэшем. Как правило, подобные пары используются для того, чтобы показать, что на этом месте в строке должен находиться символ с кодом, который не имеет соответствующего ему изображения или же символ, принадлежащий какой-то определённой группе символов.</p>
<p>&nbsp;</p>
<p><span style="font-weight: bold;">Метасимволы для задания символов, не имеющих изображения</span></p>
<p>&nbsp;</p>
<div style="text-align: left; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 0px 0px 0px 0px;"><table cellspacing="0" cellpadding="0" border="0" style="border: none; border-spacing:0px;">
<tr style="text-align:left;vertical-align:top;">
<td valign="top" width="50" style="width:50px;"><p><span style="font-weight: bold;">\n</span></p>
</td>
<td valign="top"><p>Символ перевода строки</p>
</td>
</tr>
<tr style="text-align:left;vertical-align:top;">
<td valign="top" width="50" style="width:50px;"><p><span style="font-weight: bold;">\r</span></p>
</td>
<td valign="top"><p>Символ возврата каретки</p>
</td>
</tr>
<tr style="text-align:left;vertical-align:top;">
<td valign="top" width="50" style="width:50px;"><p><span style="font-weight: bold;">\t</span></p>
</td>
<td valign="top"><p>Символ табуляции</p>
</td>
</tr>
</table>
</div>
<p>&nbsp;</p>
<p><span style="font-weight: bold;">Метасимволы для задания групп символов</span></p>
<p>&nbsp;</p>
<div style="text-align: left; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 0px 0px 0px 0px;"><table cellspacing="0" cellpadding="0" border="0" style="border: none; border-spacing:0px;">
<tr style="text-align:left;vertical-align:top;">
<td valign="top" width="50" style="width:50px;"><p><span style="font-weight: bold;">\d</span></p>
</td>
<td valign="top"><p>Цифра (0-9)</p>
</td>
</tr>
<tr style="text-align:left;vertical-align:top;">
<td valign="top" width="50" style="width:50px;"><p><span style="font-weight: bold;">\D</span></p>
</td>
<td valign="top"><p>Не цифра (любой символ кроме символов 0-9)</p>
</td>
</tr>
<tr style="text-align:left;vertical-align:top;">
<td valign="top" width="50" style="width:50px;"><p><span style="font-weight: bold;">\s</span></p>
</td>
<td valign="top"><p>Пустой символ (обычно пробел и символ табуляции)</p>
</td>
</tr>
<tr style="text-align:left;vertical-align:top;">
<td valign="top" width="50" style="width:50px;"><p><span style="font-weight: bold;">\S</span></p>
</td>
<td valign="top"><p>Непустой символ (всё, кроме символов, определяемых метасимволом \s)</p>
</td>
</tr>
<tr style="text-align:left;vertical-align:top;">
<td valign="top" width="50" style="width:50px;"><p><span style="font-weight: bold;">\w</span></p>
</td>
<td valign="top"><p>&quot;Словесный&quot; символ (символ, который используется в словах. Обычно все буквы, все цифры и символ подчёркивания (&quot;<span style="font-weight: bold;">_</span>&quot;))</p>
</td>
</tr>
<tr style="text-align:left;vertical-align:top;">
<td valign="top" width="50" style="width:50px;"><p><span style="font-weight: bold;">\W</span></p>
</td>
<td valign="top"><p>Всё, кроме символов, определяемых метасимволом \w</p>
</td>
</tr>
</table>
</div>
<p>&nbsp;</p>
<p>Приведу несколько простейших примеров для того, чтобы вы понимали, о чем идёт речь. Сразу оговорюсь, что примеры несколько громоздки и некрасивы, но лишь потому, что я не стал использовать в них метасимволы, о которых ещё не рассказал и которые сделали бы их намного проще.</p>
<p>&nbsp;</p>
<div style="text-align: left; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 0px 0px 0px 0px;"><table cellspacing="0" cellpadding="0" border="0" style="border: none; border-spacing:0px;">
<tr style="text-align:left;vertical-align:top;">
<td valign="top" width="80" style="width:80px;"><p>\d\d\d</p>
</td>
<td valign="top"><p>Любое трехзначное число (&quot;123&quot;, &quot;719&quot;, &quot;001&quot;)</p>
</td>
</tr>
<tr style="text-align:left;vertical-align:top;">
<td valign="top" width="80" style="width:80px;"><p>\w\s\d\d</p>
</td>
<td valign="top"><p>Буква, пробел (или табуляция) и двузначное число (&quot;A 01&quot;, &quot;z 45&quot;, &quot;S 18&quot;)</p>
</td>
</tr>
<tr style="text-align:left;vertical-align:top;">
<td valign="top" width="80" style="width:80px;"><p>\d and \d</p>
</td>
<td valign="top"><p>Любая из следующих строк: &quot;1 and 2&quot;, &quot;9 and 5&quot;, &quot;3 and 4&quot;</p>
</td>
</tr>
</table>
</div>
<p>&nbsp;</p>
<p>Синтаксис регулярных выражений имеет средства для определения собственных подмножеств символов. Например, вам может понадобиться задать условие, что в этом месте строки должна находиться шестнадцатеричная цифра или ещё что-то подобное. Для описания таких подмножеств применяются <span style="font-weight: bold;">символы квадратных скобок &quot;[&quot; и &quot;]&quot;</span>. Квадратные скобки, встреченные внутри регулярного выражения считаются одним символом, который может принимать значения, перечисленные внутри этих скобок.</p>
<p>Есть небольшая тонкость в том, как работают метасимволы внутри квадратных скобок. Дело в том, что в синтаксисе регулярных выражений существует ещё множество метасимволов, но практически все они работают только <span style="font-weight: bold;">вне</span> секций описаний подмножеств. Единственные метасимволы, которые работают внутри этих секций это:</p>
<p>&nbsp;</p>
<p><span style="font-weight: bold;">Обратный слэш (&quot;\&quot;)</span>. Т.е. все метасимволы из приведённой ранее таблицы будут работать.</p>
<p>&nbsp;</p>
<p><span style="font-weight: bold;">Минус (&quot;-&quot;)</span>. Используется для задания набора символов из одного промежутка (например, все цифры могут быть заданы как &quot;0-9&quot;).</p>
<p>&nbsp;</p>
<p><span style="font-weight: bold;">Символ &quot;^&quot;</span>. Если этот символ стоит <span style="font-weight: bold;">первым</span> в секции задания подмножества символов (и только в этом случае!) он будет рассматриваться как символ отрицания. Т.о. можно задать все символы, которые не описаны в данной секции.</p>
<p>&nbsp;</p>
<p>Несколько примеров, чтобы было понятно, как это работает:</p>
<p>&nbsp;</p>
<div style="text-align: left; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 0px 0px 0px 0px;"><table cellspacing="0" cellpadding="0" border="0" style="border: none; border-spacing:0px;">
<tr style="text-align:left;vertical-align:top;">
<td valign="top" width="80" style="width:80px;"><p>[0-9A-Fa-f]</p>
</td>
<td valign="top"><p>Цифра в шестнадцатеричной системе счисления</p>
</td>
</tr>
<tr style="text-align:left;vertical-align:top;">
<td valign="top" width="80" style="width:80px;"><p>[\dA-Fa-f]</p>
</td>
<td valign="top"><p>То же самое, но с использованием метасимвола</p>
</td>
</tr>
<tr style="text-align:left;vertical-align:top;">
<td valign="top" width="80" style="width:80px;"><p>[02468]</p>
</td>
<td valign="top"><p>Четная цифра</p>
</td>
</tr>
<tr style="text-align:left;vertical-align:top;">
<td valign="top" width="80" style="width:80px;"><p>[^\d]</p>
</td>
<td valign="top"><p>Всё, кроме цифр (аналог метасимвола \D)</p>
</td>
</tr>
<tr style="text-align:left;vertical-align:top;">
<td valign="top" width="80" style="width:80px;"><p>[a^b]</p>
</td>
<td valign="top"><p>Любой из символов &quot;a&quot;, &quot;b&quot;, &quot;^&quot;. Заметьте, что здесь символ &quot;<span style="font-weight: bold;">^</span>&quot; не имеет какого-либо специального значения, потому что стоит не на первой позиции внутри квадратных скобок</p>
</td>
</tr>
</table>
</div>
<p>&nbsp;</p>
<p><span style="font-weight: bold;">Другие метасимволы</span></p>
<p>&nbsp;</p>
<p>Теперь необходимо рассмотреть ещё несколько метасимволов. Как уже было сказано ранее, все они работают только вне секций описаний подмножеств символов (вне квадратных скобок).</p>
<p>&nbsp;</p>
<p><span style="font-weight: bold;">Символы &quot;^&quot; и &quot;$&quot;</span>. Они используются для того, чтобы указать парсеру регулярных выражений на положение искомого текста в строке. Символ &quot;<span style="font-weight: bold;">^</span>&quot; указывает, что искомый текст должен находиться в начале строки, символ &quot;<span style="font-weight: bold;">$</span>&quot; наоборот, указывает, что искомый текст должен находиться в конце строки. Посмотрим, как это работает на примере:</p>
<p>Допустим, у нас есть текст:</p>
<p>&nbsp;</p>
<p>12 aaa bbb</p>
<p>aaa 27 ccc</p>
<p>aaa aaa 45</p>
<p>&nbsp;</p>
<p>И регулярное выражение для поиска чисел в этом тексте: &quot;(?m)\d\d&quot; (не обращайте пока внимание на &quot;(?m)&quot;). Поиск по этому регулярному выражению вернёт нам 3 значения: &quot;12&quot;, &quot;27&quot;, &quot;45&quot;. Теперь ограничим поиск, указав, где именно внутри строки должен располагаться текст: &quot;(?m)^\d\d&quot;. Здесь результат будет только один - &quot;12&quot;, потому что только это число располагается в начале строки. Аналогично, регулярное выражение &quot;(?m)\d\d$&quot; вернёт результат &quot;45&quot;.</p>
<p>&nbsp;</p>
<p><span style="font-weight: bold;">Символ точки (&quot;.&quot;)</span>. Этот метасимвол указывает, что на данном месте в строке может находиться любой символ (за исключением символа перевода строки). Очень удобно использовать его, если вам нужно &quot;пропустить&quot; какую-нибудь букву в слове при проверке. Например, регулярное выражение &quot;.bc&quot; найдёт в тексте и &quot;abc&quot; и &quot;Abc&quot; и &quot;Zbc&quot; и &quot;5bc&quot;.</p>
<p>&nbsp;</p>
<p><span style="font-weight: bold;">Символ вертикальной черты (&quot;|&quot;)</span>. Используется для задания списка альтернатив. Например, регулярное выражение &quot;(красное|зелёное) яблоко&quot; найдёт в тексте все словосочетания &quot;красное яблоко&quot; и &quot;зелёное яблоко&quot;. О значении круглых скобок в этом выражении см. далее.</p>
<p>&nbsp;</p>
<p><span style="font-weight: bold;">Символы круглых скобок (&quot;(&quot; и &quot;)&quot;)</span>. Эти символы позволяют получить из искомой строки дополнительную информацию. Обычно, если парсер регулярных выражений ищет в тексте информацию по заданному выражению и находит её - он просто возвращает найденную строку. Однако, если он встречает внутри регулярного выражения круглые скобки, то он рассматривает содержимое этих скобок как ещё одно регулярное выражение, по которому необходимо произвести поиск. Парсер рекурсивно вызывает сам себя для поиска по новому регулярному выражению и использует результаты поиска для дальнейшей обработки основного регулярного выражения. При этом, если поиск хотя бы по одному из внутренних регулярных выражений не увенчался успехом - поиск по всему регулярному выражению считается безуспешным.</p>
<p>&nbsp;</p>
<p>Чтобы было понятнее, о чем я только что рассказал - рассмотрим в качестве примера то, как работает парсер регулярных выражений в случае приведённого выше регулярного выражения о яблоках: &quot;(красное|зелёное) яблоко&quot;.</p>
<p>Парсер начинает разбор регулярного выражения и встречает выражение в скобках: &quot;(красное|зелёное)&quot;.</p>
<p>Парсер вызывает себя для поиска по найденному регулярному выражению.</p>
<p>Получив результаты поиска, парсер подставляет по очереди каждый из полученных результатов на место выражения в скобках и смотрит, удовлетворяет ли найденный результат всем условиям основного регулярного выражения (в данном случае смотрит, есть ли после найденного слова слово &quot;яблоко&quot;).</p>
<p>Если всё в порядке - результаты поиска по каждому из имеющихся регулярных выражений для этого случая возвращаются, если нет - парсер просто переходит к следующему найденному фрагменту. Результат поиска внутреннего регулярного выражения для этого фрагмента при этом теряется.</p>
<p>В качестве примера возьмем строку:</p>
<p>&nbsp;</p>
<p>яблоко красное и зелёное яблоко и ещё одно красное яблоко и ещё одно яблоко, зелёное</p>
<p>&nbsp;</p>
<p>Поиск по внутреннему регулярному выражению даст 4 результата (выделены жирным шрифтом):</p>
<p>&nbsp;</p>
<p>яблоко <span style="font-weight: bold;">красное</span> и <span style="font-weight: bold;">зелёное</span> яблоко и ещё одно <span style="font-weight: bold;">красное</span> яблоко и ещё одно яблоко, <span style="font-weight: bold;">зелёное</span></p>
<p>&nbsp;</p>
<p>Однако поиск по всему регулярному выражению даст всего 2 результата, потому как в остальных случаях условия основного регулярного выражения не выполняются:</p>
<p>&nbsp;</p>
<p>яблоко красное и <span style="font-weight: bold;">зелёное яблоко</span> и ещё одно <span style="font-weight: bold;">красное яблоко</span> и ещё одно яблоко, зелёное</p>
<p>&nbsp;</p>
<p>Необходимо заметить, что для этих двух случаев будет возвращён не только результат поиска по основному регулярному выражению, но и результат поиска по внутреннему регулярному выражению для каждого из найденных фрагментов. В большинстве случаев это полезно (пример - чуть позднее), но иногда наоборот, лучше избавиться от лишних результатов. В этом случае необходимо добавить <span style="font-weight: bold;">символы &quot;?:&quot;</span> непосредственно после открывающейся круглой скобки: &quot;(?:красное|зелёное) яблоко&quot;.</p>
<p>Теперь пример, когда получение результатов внутренних регулярных выражений может быть полезным. Допустим, нам необходимо проверить, является ли строка семизначным телефонным номером с указанием кода города, и получить из неё код города и номер телефона:</p>
<p>&nbsp;</p>
<p>\((\d{3,5})\)\s+(\d{3}-\d{2}-\d{2})</p>
<p>&nbsp;</p>
<p>Некоторые из примененных здесь метасимволов вам ещё неизвестны и будут рассмотрены чуть позднее. Давайте рассмотрим этот regexp подробнее.</p>
<p>Первая круглая скобка здесь теряет свое специальное значение и будет рассматриваться как обычный символ:</p>
<p>&nbsp;</p>
<p><span style="font-weight: bold;">\(</span>(\d{3,5})\)\s+(\d{3}-\d{2}-\d{2})</p>
<p>&nbsp;</p>
<p>Далее идёт регулярное выражение в скобках (проверка кода города):</p>
<p>&nbsp;</p>
<p>\(<span style="font-weight: bold;">(\d{3,5})</span>\)\s+(\d{3}-\d{2}-\d{2})</p>
<p>&nbsp;</p>
<p>После этого идёт закрывающая круглая скобка, которая также лишена своего специального значения из-за символа обратного слэша, стоящего перед ней:</p>
<p>&nbsp;</p>
<p>\((\d{3,5})<span style="font-weight: bold;">\)</span>\s+(\d{3}-\d{2}-\d{2})</p>
<p>&nbsp;</p>
<p>Затем идёт пропуск пустого места:</p>
<p>&nbsp;</p>
<p>\((\d{3,5})\)<span style="font-weight: bold;">\s+</span>(\d{3}-\d{2}-\d{2})</p>
<p>&nbsp;</p>
<p>И ещё одно регулярное выражение в скобках, которое проверяет номер телефона:</p>
<p>&nbsp;</p>
<p>\((\d{3,5})\)\s+<span style="font-weight: bold;">(\d{3}-\d{2}-\d{2})</span></p>
<p>&nbsp;</p>
<p>Как видите, здесь есть 3 регулярных выражения - основное и два внутренних. При этом основное выражение позволяет нам проверить, имеет ли строка необходимый нам формат, а два внутренних - получить соответственно код города и номер телефона. Т.е. одним регулярным выражением мы можем решить сразу несколько задач!</p>
<p>Посмотрим, как работает это регулярное выражение. Пусть у нас есть строка: &quot;My phone is (095) 123-45-67&quot;. Результатами поиска будут 3 строки:</p>
<p>&nbsp;</p>
<p>&quot;(095) 123-45-67&quot;</p>
<p>&quot;095&quot;</p>
<p>&quot;123-45-67&quot;</p>
<p>&nbsp;</p>
<p>Нам осталось рассмотреть ещё одну группу метасимволов, определяющих количественные показатели (т.н. <span style="font-weight: bold;">квантификаторы</span>). Как вы уже могли заметить ранее - очень часто бывает необходимо указать, что какой-то символ должен повторяться определённое количество раз. Конечно, можно просто указать его необходимое количество раз непосредственно в строке, но это, естественно не выход. Тем более, что очень часто встречаются ситуации, когда точное количество символов неизвестно. Поэтому синтаксис регулярных выражений содержит набор метасимволов, предназначенных именно для решения подобных задач. Каждый из описанных ниже метасимволов определяет количественную характеристику символа, который находится <span style="font-weight: bold;">непосредственно</span> перед ним.</p>
<p>&nbsp;</p>
<p><span style="font-weight: bold;">Звездочка (&quot;*&quot;)</span>. Указывает, что символ должен быть повторен 0 или более раз (т.е. символ может отсутствовать или присутствовать в любых количествах). Пример: выражение &quot;ab*c&quot; найдёт строки &quot;ac&quot;, &quot;abc&quot;, &quot;abbc&quot; и т.д.</p>
<p>&nbsp;</p>
<p><span style="font-weight: bold;">Плюс (&quot;+&quot;)</span>. Указывает, что символ должен быть повторен 1 или более раз (т.е. символ обязан присутствовать, и может присутствовать в любых количествах). Пример: выражение &quot;ab+c&quot; найдёт строки &quot;abc&quot;, &quot;abbc&quot;, &quot;abbbc&quot; и т.д., но не найдёт строку &quot;ac&quot;.</p>
<p>&nbsp;</p>
<p><span style="font-weight: bold;">Символ вопроса (&quot;?&quot;)</span>. Указывает, что символ может как присутствовать, так и нет, но при этом не может повторяться более одного раза. Пример: выражение &quot;ab?c&quot; найдёт строки &quot;ac&quot; и &quot;abc&quot;, но не найдёт строку &quot;abbc&quot;.</p>
<p>&nbsp;</p>
<p><span style="font-weight: bold;">Фигурные скобки (&quot;{&quot; и &quot;}&quot;)</span>. Определяют количественную характеристику символа. Внутри скобок через запятую перечисляются минимальное и максимальное количество повторений символа. При этом любой из параметров может быть опущен, а, кроме того, можно задать точное количество повторений, указав только одно число.</p>
<p>Примеры:</p>
<p>&nbsp;</p>
<p>{2,4} - символ должен повториться минимум 2 раза, но не более 4.</p>
<p>{,5} - символ может отсутствовать (т.к. не задано минимальное количество повторений), но если присутствует, то не должен повторяться более 5 раз.</p>
<p>{3,} - символ должен повторяться минимум 3 раза, но может быть и больше.</p>
<p>{4} - символ должен повторяться ровно 4 раза.</p>
<p>&nbsp;</p>
<p>Есть ещё одна тонкость в использовании метасимвола &quot;<span style="font-weight: bold;">?</span>&quot;. Посмотрите на такое выражение: &quot;.+a&quot;. Ожидается, что оно вернёт нам часть текста до первого вхождения символа &quot;a&quot; в этот текст. На самом деле оно будет работать несколько не так, как ожидается и результатом поиска будет весь текст до <span style="font-weight: bold;">последнего</span> вхождения символа &quot;a&quot;. Дело в том, что по умолчанию количественные метасимволы &quot;жадничают&quot; и пытаются захватить как можно больший кусок текста. Если это не нужно (как в нашем случае), то необходимо &quot;отучить&quot; их от жадности, указав символ &quot;<span style="font-weight: bold;">?</span>&quot; после количественного метасимвола: &quot;.+?a&quot;. После этого выражение будет работать так как надо.</p>
<p>&nbsp;</p>
<p><span style="font-weight: bold;">Модификаторы регулярных выражений</span></p>
<p>&nbsp;</p>
<p>Механизм регулярных выражений позволяет добавлять модификаторы, влияющие на обработку регулярного выражения.</p>
<p>Запись модификаторов производится посредством указания последовательности &quot;(?модификатор)&quot;. Для отмены действия модификатора используется запись &quot;(?-модификатор)&quot;.</p>
<p>&nbsp;</p>
<div style="text-align: left; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 0px 0px 0px 0px;"><table cellspacing="0" cellpadding="0" border="0" style="border: none; border-spacing:0px;">
<tr style="text-align:left;vertical-align:top;">
<td valign="top" width="50" style="width:50px;"><p><span style="font-weight: bold;">i</span></p>
</td>
<td valign="top"><p>Включение режима case-insensitive, т.е. большие и маленькие буквы в выражении не различаются.</p>
</td>
</tr>
<tr style="text-align:left;vertical-align:top;">
<td valign="top" width="50" style="width:50px;"><p><span style="font-weight: bold;">m</span></p>
</td>
<td valign="top"><p>Указывает на то, что текст, по которому ведётся поиск, должен рассматриваться как состоящий из нескольких строк. По умолчанию механизм регулярных выражений рассматривает текст как одну строку вне зависимости от того, чем она является на самом деле. Соответственно метасимволы &quot;<span style="font-weight: bold;">^</span>&quot; и &quot;<span style="font-weight: bold;">$</span>&quot; указывают на начало и конец всего текста. Если же этот модификатор указан, то они будут указывать соответственно на начало и конец каждой строки текста.</p>
</td>
</tr>
<tr style="text-align:left;vertical-align:top;">
<td valign="top" width="50" style="width:50px;"><p><span style="font-weight: bold;">s</span></p>
</td>
<td valign="top"><p>По-умолчанию, метасимвол &quot;<span style="font-weight: bold;">.</span>&quot; не включает в свое определение символ перевода строки. Т.е. для многострочного текста выражение &quot;.+&quot; вернёт только первую строку, а не весь текст, как ожидается. Указание этого модификатора снимает это ограничение.</p>
</td>
</tr>
</table>
</div>

</td></tr></table>

</body>
</html>
