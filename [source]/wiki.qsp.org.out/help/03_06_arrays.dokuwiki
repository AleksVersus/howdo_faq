[[help:coding|Назад: Программный код]]

====== Массивы ======

===== Зачем нужны массивы =====

Иногда нам становится неудобно хранить множество однотипных значений в разных переменных. Например, у нас есть двадцать "железных мечей" и для каждого мы прописали урон в двадцати разных переменных:

<sxh qsp>
меч_железный_1 = 23
меч_железный_2 = 34
меч_железный_3 = 27
...
меч_железный_19 = 7
меч_железный_20 = 41
</sxh>

Даже для того, чтобы просто вывести на экран данную характеристику для каждого меча, нам придётся написать двадцать строчек кода, почти ничем не отличающихся:

<sxh qsp>
*pl "Меч железный №1. Урон: "+$str(меч_железный_1)
*pl "Меч железный №2. Урон: "+$str(меч_железный_2)
*pl "Меч железный №3. Урон: "+$str(меч_железный_3)
...
*pl "Меч железный №19. Урон: "+$str(меч_железный_19)
*pl "Меч железный №20. Урон: "+$str(меч_железный_20)
</sxh>

Всё бы ничего, но что если нам нужно найти среди всех этих переменных ту, которая содержит максимальное число (мы ведь хотим пользоваться самым хорошим мечом)? Тут нам придётся городить огромную конструкцию условий, которая сравнивает каждую переменную со всеми остальными, и объём необходимого нам кода возрастает многократно.

Да, есть некоторые варианты решения этих двух задач без использования массивов, но они тоже весьма сложны. Куда как проще работать с однотипными данными, если они представлены в форме массива.

Если переменную мы можем вообразить в виде отдельной маленькой коробки, в которую можно положить лишь одно значение, то массив — это большой шкаф, со множеством пронумерованных ящиков (ячеек), в каждый из которых мы можем положить по одному значению.

===== Что такое массивы =====

**Массив** - в **QSP** это последовательный набор значений, записанных под одним общим именем.

Например, вместо того, чтобы помещать урон каждого железного меча в отдельную переменную, мы заводим массив, и размещаем значения уронов от разных мечей в ячейках этого массива.

Имена переменных и имена массивов записываются похожим образом. Единственное отличие в том, что когда мы обращаемся к массиву — возле его имени в квадратных скобках ставим номер одной из ячеек.

<sxh qsp>
меч_железный[0] = 23 & ! нумерация ячеек массива начинается с нуля
меч_железный[1] = 34
меч_железный[2] = 27
...
меч_железный[18] = 7
меч_железный[19] = 41 & ! значение для двадцатого меча лежит в ячейке под номером 19
</sxh>

Из этого примера видно, чтобы записать значение в отдельную ячейку массива, мы должны:

  * Написать имя массива;
  * затем без пробелов, не отступая от имени массива, в квадратных скобках написать номер ячейки, в которую хотим записать значение;
  * затем поставить знак ''**=**'' (операция присваивания);
  * и уже после знака **равно** написать нужное значение.

В нашем примере массив называется "меч_железный", а в квадратных скобках мы указываем номера ячеек этого массива.

==== Создание массива ====

Записывая значения хотя бы в одну ячейку массива, мы тем самым **создаём** (инициализируем) весь массив.

  * Ячейки массива так же называются **элементами**.
  * Любой массив состоит из одного или множества элементов, и у каждого элемента есть собственный номер.
  * Номера элементов начинаются с нуля и не повторяются.
  * Нумерация элементов массива не прерывается. То есть, например, не может в массиве существовать четвёртый элемент, но отсутствовать второй и третий. Если мы создадим только нулевой и первый, а так же четвёртый, элементы массива, второй и третий — будут созданы автоматически: <sxh qsp>
mass[0]=13
mass[1]=19
mass[4]=23
! элементы mass[2] и mass[3] созданы автоматически и хранят значения по умолчанию (т.е. 0)
</sxh>
  * Максимальный возможный номер ячейки массива ''**2147483647**''.
  * Минимально возможный номер ячейки массива ''**0**''. QSP не допускает создания ячеек с отрицательным индексом и не работает с такими ячейками. Плеер игнорирует команды присвоения, и возвращает значение по умолчанию при попытке обратиться к такой ячейке.

==== Типы данных в массивах ====

Массив можно представить себе как **список** значений. Если вам нужно хранить только одно значение, достаточно обычной переменной, но если вам нужно сохранить множество значений, как некий список, то обязательно используйте массив. Например, вы можете вести список имён всех встреченных персонажей:

<sxh qsp>
$встреченные_неписи[0] = "Домовёнок Нафаня"
$встреченные_неписи[1] = "Девочка Оля"
$встреченные_неписи[2] = "Лариса Петровна"
$встреченные_неписи[3] = "Баба Яга"
</sxh>

В данном примере мы помещали в массив строковые значения.

Чтобы поместить в ячейку массива строковое значение, нужно поставить перед именем массива символ ''**%%$%%**''.

То же самое и в случае, когда мы хотим получить значение из ячейки массива:

если мы хотим получить строковое значение, нужно поставить символ ''**%%$%%**'' перед именем массива.

И точно так же это работает для числовых значений и [[help:tuples|кортежей]]:
  * Если нам нужно присвоить ячейке массива, или получить из неё, числовое значение, никаких символов мы перед именем массива не ставим.
  * Если нам нужно присвоить ячейке массива, или получить из неё, кортеж, ставим символ ''**%**'' перед именем массива.

Примеры:

<sxh qsp>
$яблоки[0]='антоновка'
$яблоки[1]='белый налив'
$яблоки[2]='астраханское'
$яблоки[3]='ранетка'
$яблоки[4]='симиренко'

сорт_яблока[0] = 1
сорт_яблока[1] = 2
сорт_яблока[2] = 4

%сорта_в_корзине[0] = [1, 4]
%сорта_в_корзине[1] = [2, 4]
%сорта_в_корзине[2] = [1, 2]

*pl $яблоки[сорт_яблока[номер_яблока]]
</sxh>

**В одном массиве** допускается хранить значения любых типов, однако строго рекомендуем хранить в одном массиве только значения одного типа: либо строковые, либо числовые, либо кортежи, — во избежание возможных [[glossary:bag|багов]].

**В одной ячейке массива** можно хранить значение только одного типа! Если вы запишете в ячейку, которая хранит строку, числовое значение — это числовое значение "затрёт" строковое. И точно так же со значением любого другого типа.

==== Обработка массивов ====

Преимущество работы с массивами по сравнению с обычными переменными раскрывается, когда нам приходится много раз повторять одну и ту же операцию над похожими значениями.

В примере из начала статьи мы помещали наносимый железным мечом урон для двадцати разных мечей в двадцать отдельных переменных и видели, что даже такая простая операция, как вывод значений всех этих переменных на экран требует огромного количества кода. Совсем другое дело, когда мы поместили наши данные в массив, ведь мы можем перебрать весь массив с помощью простого цикла:

<sxh qsp>
меч_железный[0] = 23 & ! нумерация ячеек массива начинается с нуля
меч_железный[1] = 34
меч_железный[2] = 27
...
меч_железный[18] = 7
меч_железный[19] = 41 & ! значение для двадцатого меча лежит в ячейке под номером 19

! выводим на экран список с помощью цикла
loop i=0 while i<20 step i+=1:
  *pl "Меч железный №<<i+1>>. Урон: "+$str(меч_железный[i])
end
</sxh>

В этом примере для вывода на экран всех значений из всех двадцати ячеек массива нам потребовалось написать всего три строчки кода.

А вот как выглядит поиск железного меча с наибольшим значением урона:

<sxh qsp>
pos = arrpos('меч_железный', max('меч_железный'))
*pl "Наибольший урон имеет Меч железный №<<pos+1>>: "+$str(меч_железный[pos])
</sxh>

В обоих примерах вместо указания конкретного номера ячейки массива, при получении данных из массива, мы подставляли значение переменной. Именно эта возможность позволяет так легко и быстро обрабатывать множество данных в массивах, и делает работу с ними более удобной, чем с обычными переменными.

==== Индексирование элементов массива ====

Выше мы писали, что ячейки массивов нумеруются подряд, начиная с нуля, и нумерация эта не прерывается. Номер ячейки массива называется **числовым индексом ячейки массива**.

<sxh qsp>
! ячейки массивов индексируются через числа
$любимый_сорт[3] = $яблоки[2]
любимое_число[19] = 5
$item_loc[0] = 'лес'
</sxh>

**Важно!** Настоятельно не рекомендуем использовать большие числовые индексы без необходимости.

**QSP** позволяет создавать для элементов массивов не только числовые, но и строковые индексы. Иными словами массивы могут //индексироваться через строки//. Примеры:

<sxh qsp>
! ячейки массивов индексируются через строки
$любимый_сорт['Иван'] = $яблоки[2]
любимое_число['Алексей'] = 5
$item_loc['палка'] = 'лес'
</sxh>

Регистр символов в строковом индексе массива значения не имеет:

<sxh qsp>
$любимый_сорт['иван'] = 'Антоновка'
*pl $любимый_сорт['ИВАН'] & ! выведет строку Антоновка
</sxh>

Есть небольшая хитрость в том, как назначаются строковые индексы ячейкам массивов. Когда вы инициализируете (создаёте, объявляете) новую ячейку массива со строковым индексом, происходит следующее:

  * Плеер создаёт новую ячейку с новым числовым индексом, следующим по порядку. Например, если в массиве уже были созданы три ячейки, создаётся ячейка с числовым индексом ''%%3%%''.
  * Затем плеер "прикрепляет" указанный строковый индекс к этой ячейке.

Поэтому, если вы создаёте ячейку со строковым индексом, вы можете получать из неё значения в том числе и по числовому индексу:

<sxh qsp>
яблоки['у Паши']=37
яблоки['у Даши']=19
яблоки['у Лёши']=11
*pl яблоки[0] & ! выведет на экран число 37
*pl яблоки[1] & ! выведет на экран число 19
*pl яблоки[2] & ! выведет на экран число 11
</sxh>

**Настоятельно рекомендуется** использовать для индексирования или только числовые, или только строковые индексы.

Строковые индексы позволяют обойти ограничение массивов на начало нумерации только с нуля:

<sxh qsp>
$item['-2']='Палка'
$item['-1']='Дрель'
$item['0']='Радиоактивный пепел'
</sxh>

==== Многомерные массивы ====

Начиная с плееров версии 5.8.0 вы можете создавать в QSP [[help:multid_array|многомерные массивы]].

==== Упрощённый доступ к ячейкам массивов ====

На самом деле каждая переменная в QSP является массивом, состоящим из одной единственной ячейки:

<sxh qsp>
яблоки = 0
!эквивалентно
яблоки[0] = 0
</sxh>

то есть, если мы создаём переменную с именем "яблоко", мы тем самым создаём массив с именем "яблоко", состоящий из одной ячейки.

Таким образом вы всегда можете получить или присвоить данные нулевой ячейке массива, просто указав его имя:

<sxh qsp>
! присваиваем нулевой ячейке массива '$COUNTER' строковое значение
$usercom = 'строка_ввода'
*pl $usercom[0] & ! проверяем
! присваиваем нулевым ячейкам массивов red, green, blue значения
set red[0], green[0], blue[0] = 234,198,77
*pl "red: <<red>>, green: <<green>>, blue: <<blue>>" & ! проверяем
</sxh>

Существует упрощённый синтаксис чтения последнего и добавления нового элемента в массив. Для этого квадратные скобки пишутся без указания индекса:

  * при записи значения в массив будет создан новый элемент сразу за последним. Например: <sxh qsp>
! Если массив был пустой, то
$objs[] = 'Напильник' &! $objs[0] = 'Напильник'
$objs[] = 'Топор' &! $objs[1] = 'Топор'
$objs[] = 'Доска' &! $objs[2] = 'Доска'
</sxh>
  * при получении значения из массива будет выбран последний элемент. Например: <sxh qsp>
*pl $objs[] &! 'Доска' из примера выше
</sxh>

===== Функции и операторы для работы с массивами =====

  * ''**KILLVAR** [$имя_массива], [индекс_элемента]'' - удаление элемента с индексом ''%%[индекс_элемента]%%'' из массива с названием ''%%[$имя_массива]%%''. Название массива всегда нужно писать в кавычках. Пример: <sxh qsp>
! удаление по числовому индексу
killvar 'яблоко',3
! удаление элемента по строковому индексу
killvar '$item_loc','палка'
! удаление элемента по многомерному индексу (кортежу)
killvar '$space',[0,-2,9]
%map_point = [0, -2, 13]
killvar '$space', %map_point
</sxh>
    * Если индекс элемента не указан, то удаляется весь массив. <sxh qsp>
! удаляем массив $map целиком
killvar '$map'
</sxh>
    * Если оператор вызван без аргументов, то удаляются все массивы и переменные в игре! <sxh qsp>
! удаляем все массивы и переменные
KILLVAR
</sxh>
    * При удалении элемента все следующие за ним элементы сдвигаются на позицию вверх. <sxh qsp>
a[0]=4
a[1]=3
a[2]=23
a[3]=15
KILLVAR 'a',1
!теперь массив выглядит так:
a[0]=4
a[1]=23
a[2]=15
</sxh>
  * ''**KILLALL**'' - оператор эквивалентен конструкции "''%%KILLVAR & KILLOBJ%%''", то есть удаляет все переменные/массивы в игре, а так же очищает Окно предметов. Обычно применяется в начале игры, чтобы при возврате в начальную локацию после неудачного прохождения какого-то этапа игры обнулить все переменные (в противном случае, может оказаться, что запертые двери уже открыты, жена похищена до свадьбы, а Баба-Яга уже отдала кому-то нужный клубочек).
  * ''**COPYARR** [$приёмник],[$источник],[#начало],[#количество]'' - копирование в массив-приёмник ''%%[#количество]%%'' элементов из массива-источника начиная с элемента под номером ''%%[#начало]%%''. Размер массива-приёмника при копировании не имеет значения.
    * Параметр ''%%[#количество]%%'' является необязательным. По умолчанию - до конца массива-источника.
    * Параметр ''%%[#начало]%%'' является необязательным. По умолчанию - ''%%0%%''.
    * Не имеет значения, указываете ли вы ''%%$%%'' или ''%'' перед названием массива, или нет. Копируются элементы с любыми типами значений.
    * Примеры: <sxh qsp>
COPYARR '$a','$b'
COPYARR 'a','b'
! $arrname1, $arrname2 = 'arr', 'bar'
COPYARR $arrname1,$arrname2,10,5
COPYARR 'a<<$arrname1>>','a<<$arrname2>>'
</sxh>
  * ''**SORTARR** [$имя_массива], [#порядок]'' — Данный оператор сортирует указанный массив. Параметр ''%%[#порядок]%%'' опционален. Если не указан или равен 0, то сортирует массив по возрастанию (от меньшего к большему). Если равен 1, то сортирует массив по убыванию (от большего к меньшему).
    * Может сортировать массивы любых типов (числа, строки, кортежи), но не допускается смешивать значения разных типов в одном массиве.
    * Для указания типа сортируемых значений нужно указать префикс типа как часть имени массива (''%%$%%'', ''%'').
    * Пример сортировки текстового массива: <sxh qsp>
$a[] = 'nn'
$a[] = 'zz'
$a[] = 'aa'
sortarr '$a'
!проверяем результат сортировки:
loop local i=0 while i<arrsize('$a') step i+=1:
  *pl $a[i]
end
</sxh>
  * ''**SCANSTR** [$имя_массива], [$текст_для_разбора], [$регэксп], [#номер_группы]'' — в массив ''%%[$имя_массива]%%'' помещаются строки, соответствующие [[help:regexp|регулярному выражению]] ''%%[$регэксп]%%'', которые будут найдены в строке ''%%[$текст_для_разбора]%%''. Если указан параметр ''%%[#номер_группы]%%'', в массив будет помещаться не вся строка, соответствующая регулярному выражению, а лишь часть, соответствующая указанной группе в этом регулярном выражении. Примеры: <sxh qsp>
! вытаскиваем из строки все слова:
$text = 'Шла Саша по шоссе, а Грека через реку.'
scanstr '$words', $text, '\b\w+\b'
!В массиве $words окажутся значения: 'Шла', 'Саша', 'по', 'шоссе', 'а', 'Грека', 'через', 'реку'

! разбиваем строку по разделителю:
$text = 'утро|день|вечер|ночь' 
scanstr '$words', $text, '[^|]+'
!В массиве $words окажутся значения: 'утро', 'день', 'вечер', 'ночь'

! вытаскиваем из строки все слова, помещённые в квадратные скобки, но без квадратных скобок:
$text = '[first] ignoredtext [second][third] also ignored' 
scanstr '$words', $text, '\[(.*?)\]', 1
!В массиве $words окажутся значения: 'first', 'second', 'third'
</sxh>
  * ''**ARRITEM(**[$имя_массива],[индекс_элемента]**)**'' — возвращает значение элемента массива с названием ''%%[$имя_массива]%%'' по указанному индексу. То есть функция извлекает значение из указанной ячейки массива. Примеры: <sxh qsp>
! выводим значение элемента с индексом 3
*pl $arritem('$mass', 3)
! выводим значение элемента с текстовым индексом
*pl $arritem('$mass', 'Петя')
! выводим значение элемента с многомерным индексом
*pl $arritem('$mass', [-2, 9, 0])
</sxh> Эта функция может быть полезна для извлечения значений, если имя массива заранее не известно. Пример: <sxh qsp>
! выводим содержимое нескольких массивов без использования ''**DYNAMIC**'':
$array_name[]='mass_1'
$array_name[]='mass_2'
$array_name[]='mass_3'
$array_name[]='mass_4'
$array_name[]='mass_5'
! внешний цикл перебирает имена массивов
loop local j=0 while j<arrsize('$array_name') step j+=1:
    ! внутренний цикл выводит содержимое массивов
    loop local i=0 while i<arrsize($array_name[j]) step i+=1:

   *pl arritem($array_name[j], i)
    end
end
</sxh>
  * ''**SETVAR** [$имя_массива], [значение], [индекс]'' — устанавливает значение элемента массива с названием ''%%[$имя_массива]%%'' по указанному индексу. То есть оператор присваивает значение указанной ячейке массива. Префикс имени переменной указывает тип значения, которое нужно записать в элемент массива (как с обычными присваиваниями). Параметр ''[индекс]'' опционален. Если этот параметр не указан, то значение присваивается 0-му элементу. Значение и индекс могут быть любых типов. Примеры: <sxh qsp>
SETVAR 'A', 65
SETVAR '$X', 'name', 4
SETVAR '$X', 'name', 'string index'
SETVAR '%Q', ['пример', 'кортежа'], 3
SETVAR '%Q', ['пример', 'кортежа'], [x, y]
</sxh> Данный оператор дополняет функцию ''**ARRITEM**'' и позволяет избегать использования ''DYNAMIC'' в некоторых случаях.
  * ''**ARRSIZE(**[$имя_массива]**)**'' - функция возвращает число элементов массива с названием ''%%[$имя_массива]%%''.
    * Не имеет значения, указываете ли вы ''%%$%%'' или ''%%%%%'' перед названием массива или нет. Подсчитывается общее число ячеек и со значениями любых типов.
    * Примеры: <sxh qsp>
n = ARRSIZE('a')
n = ARRSIZE('$a')
!Результат будет одинаковый
</sxh>
  * ''**ARRTYPE(**[$имя_переменной], [индекс]**)**'' - получает тип значения, которое хранится в массиве ''%%[$имя_переменной]%%'' под индексом ''[индекс]''.
    * Параметр ''%%[индекс]%%'' может отсутствовать, при этом он принимается равным ''0''. То есть вычисляется тип значения переменной/нулевой ячейки массива. Индекс может быть любого типа.
    * Функция возвращает одно из следующих значений в зависимости от типа:
      * ''%%''%%'' (пустая строка) - элемент массива не задан.
      * ''%%'#'%%'' - элемент содержит число.
      * ''%%'$'%%'' - элемент содержит строку.
      * ''%%'%'%%'' - элемент содержит кортеж.
    * Пример: <sxh qsp>
$ddd = 'text'
$arrtype('ddd') & ! '$'

$g = 'text' & g = 13
$arrtype('g') & ! '#'

%tuple['index'] = [12, 'string']
$arrtype('tuple', 'index') & ! '%'

! $empty not exist
$arrtype('$empty') & ! ''
</sxh>
  * ''**ARRPOS(**[$имя_массива], [значение], [#старт]**)**'' — возвращает индекс элемента массива равного указанному значению.
    * Поиск начинается с элемента с заданным номером ''[#старт]''.
    * Индексация элементов массива ведётся с нуля.
    * Если указанное значение не найдено, функция возвращает -1.
    * Пример: <sxh qsp>
$color[0] = 'красный'
$color[1] = 'жёлтый'
$color[2] = 'зелёный'
$color[3] = 'синий'
$color[4] = 'жёлтый'

arrpos('$color', 'жёлтый') & ! вернёт значение 1
arrpos('$color', 'жёлтый', 2) & ! вернёт значение 4
arrpos('$color','голубой') & ! вернёт значение -1
</sxh>
    * Другие примеры: <sxh qsp>
! поиск строки 'this' в текстовом массиве "$a"
arrpos('$a', 'this', 0)
! поиск числа 65 в массиве "a" (два элемента массива игнорируются)
arrpos('a', 65, 2)
! поиск строки 'test' среди значений массива "$b"
arrpos('$b', 'test')
</sxh>
    * Можно искать значения любого типа, однако:
      * если вы ищете среди текстовых значений массива, нужно указывать префикс типа ''$'' перед названием массива;
      * если вы ищете среди кортежей в массиве, нужно указывать префикс типа ''%''.
      * Пример: <sxh qsp>
$a[0] = '12'
a[1] = 12
%a[2] = [12]
%a[3] = ['12']
arrpos('$a', 12)     &  ! 0
arrpos('a', 12)      &  ! 1 
arrpos('%a', 12)     &  ! 2
arrpos('%a', '12')   &  ! 2 <---
arrpos('%a', [12])   &  ! 2
arrpos('%a', ['12']) &  ! 2 <---
</sxh>
  * ''**MAX(**[выр1],[выр2], …**)**'' - возвращает максимальное из значений выражений-аргументов. Если передан один аргумент, то считается, что указано имя массива: <sxh qsp>
MAX('a') &! вернёт максимальное из числовых значений элементов массива "a"
MAX('$b') &! вернёт максимальное из текстовых значений элементов массива "$b"
MAX('%d') &! вернёт максимальный из кортежей в массиве '%d'
</sxh>
  * ''**MIN(**[выр1],[выр2], …**)**'' - возвращает минимальное из значений выражений-аргументов. Если передан один аргумент, то считается, что указано имя массива: <sxh qsp>
MIN('a') &! вернёт минимальное из числовых значений элементов массива "a"
MIN('$b') &! вернёт минимальное из текстовых значений элементов массива "$b"
MIN('%d') &! вернёт минимальный из кортежей в массиве '%d'
</sxh>
  * ''**ARRCOMP(**[$имя_массива],[$шаблон],[#начало]**)**'' - возвращает номер элемента массива ''%%[$имя_массива]%%'', соответствующего регулярному выражению ''%%[$шаблон]%%''. Поиск начинается с элемента с номером ''%%[#начало]%%''; индексация элементов массива ведётся с нуля. Если указанное значение не найдено, функция возвращает ''%%-1%%''.
    * Поиск работает только по текстовым массивам (символ ''%%$%%'' в названии массива можно опустить).
    * Параметр ''%%[#начало]%%'' может отсутствовать, при этом он принимается равным ''%%0%%''.
    * Примеры: <sxh qsp>
!Поиск строки 'This' среди элементов массива "$A"
ARRCOMP('$A','This',0)
!'Поиск строки, соответствующей регулярному выражению "abc\d+"
(первые два элемента массива игнорируются)'
ARRCOMP('$A','abc\d+',2)
!'аналогично предыдущему примеру, но поиск осуществляется
по всем элементам массива'
ARRCOMP('$A','.*string.*',0)
ARRCOMP('$A','This') &! эквивалентно 1му варианту
</sxh>
    * Функция возвращает только числовой индекс элемента. Строковый или многомерный индекс с помощью данной функции получить нельзя.

Так же см. ARRPACK и UNPACKARR в разделе [[help:tuples|"Кортежи"]]

[[help:strings|Вперёд: Строки]]
