вопросы про время

-----------------------------------------------------------------------
=DaRkNeSSxSiTH=
https://qsp.org/index.php?option=com_agora&task=topic&id=40&p=116&prc=25&Itemid=57#p20221
Тут чуть выше задавали вопрос про время, у меня возник такой же... воспользовался советом Storma сделав дополнительную локацию "Статус" и там задал время: 

время=время+5 
дни=время/(24*60) 
часы=(время-дни*24*60)/60 
минуты=время-часы*60-дни*24*60

Как сделать отображение месяцев и дней недели? чтобы выглядело примерно так - 3 февраля Понедельник 23:57 ? 
Опять же - если возможность отображать минуты, если они менее 10 с нулём спереди? т.е время - не 23:5, 23:05 ?

=Nex=
! Инициализация при старте игры. 
$month_name[] = 'января' 
$month_name[] = 'февраля' 
... 
$month_name[] = 'декабря' 

$weekday_name[] = 'Понедельник' 
$weekday_name[] = 'Вторник' 
... 
$weekday_name[] = 'Воскресенье' 

! Вычисляем текущий месяц. 
month = (days/30) MOD 12 
month_day = days MOD 30 + 1 

! Вычисляем текущий день недели. 
weekday = days MOD 7 

! Добавляем ноль к минутам, если требуется. 
$min = IIF(min < 10, '0' + STR(min), STR(min)) 

! Выводим дату и время. 
'<<month_day>> <<$mohtn_name[month]>> <<$weekday_name[weekday]>> <<hour>>:<<$min>>'


-----------------------------------------------------------------------------------
=svandrus=
https://qsp.org/index.php?option=com_agora&task=topic&id=40&p=117&prc=25&Itemid=57#p20280
Раз уж про календари и время рассказывают, тогда и я спрошу: 
1. Сделал время не через локацию-счетчик, а проверяя #time. Герой ложится спать и просыпается через 8 часов и время у него 28:22. Чтобы этого избежать, прописал так: 

IF hour = 24: hour = 0 
IF hour = 25: hour = 1 
IF hour = 26: hour = 2 
etc.

но мне этот способ не слишком нравится. Должно же быть как-то правильно? По идее, должно хватать только первой строчки.

2. Спрашивал уже, но ответа не получил, поэтому опять спрашиваю. 
На локации-счетчике сделал время (секундомер). Запустить его в реал-тайме из другой локации у меня получилось, а вот остановить, а потом опять запустить с остановленного места - нет.

=Nex=
Должно же быть как-то правильно?
Правильно тут. https://qsp.org/index.php?option=com_content&view=article&id=111:-10&catid=36:2009-02-19-06-11-21&Itemid=76
"Прошло 8 часов" в коде должно записываться так: 

время += 8*60
После каждого изменения переменной "время", ты должен заново пересчитать значения минут, часов и т.д.

=Axil=
if hour >= 24: 
:loophour 
	day = day + 1 
	week = week + 1 
	hour = hour - 24 
	if hour >= 24: jump 'loophour' 
end 
Проверка и jump там на всякий случай, мало ли, вы двое суток спали.

=svandrus=
Про время - предложенный модуль хорош, но сложноват для меня. Свою задачу сформулировал так - возможность пове.. управлять течением времени и решил немножко по-другому: 

act 'Остановись мгновение...': 
	delact $selact 
	SETTIMER  999999 
	act 'Реал-тайм': 
		delact $selact 
		SETTIMER  500 
		gt $curloc 
	end 
end

Получил в итоге иллюзию паузы и вопрос: каким может быть предельное значение SETTIMER? 
P.S. Сделал SETTIMER -1 и оно замерло. Надолго ли?

=Aleks Versus=
Да, если выставить settimer <1, выполнение кода на локации counter не происходит никогда.

------------------------------------------------------------------------------------------
=Dogon=
https://qsp.org/index.php?option=com_agora&task=topic&id=40&p=127&prc=25&Itemid=57#p20893
Обясните ламеру пожалуйста как сделать так чтоб деньги (ресурсы, опыт и т.п.) поступали не по клику скажем "следующий день", а по истечении скажем 10 секунд. У меня если мысль что как то через самооновляющуюся локацию или что то на подобии, но на деле как реализовать не получилось. Будьте добры пример если такое возможно. Спасибо.
=Dogon=
Нужно использовать оператор wait я так понимаю?

=Aleks Versus=
Если речь идёт о реальном времени (реалтайм), то необходимо орагнизовать вычисление времени через локацию-счётчик
--------------------------------------------------------------
=Dower.Hollower=
https://qsp.org/index.php?option=com_agora&task=topic&id=40&p=141&prc=25&Itemid=57#p21724
Ох, ребят, помогите пожалуйста. Бьюсь второй день об бубен - мозгов не прибавляется. 
Прочёл статью по игровому времени:

дни = время / (24*60) 
часы = (время - дни*24*60) / 60 
минуты = время - часы*60 - дни*24*60 
*PL 'Время: <<дни>> день, <<часы>>:<<минуты>>.' 

Но мне формат времени нужен следующий: [День недели], [Время:XX:XX], [Дата:День.Месяц.Год] 

Вопроса два:
1. Как сделать то, что я описал? 

2. Не могу врубится в формулу описанную Nexом. Т.е. почему именно так: дни = время / (24*60), и что есть "время" в этой формуле. 
Запутался окончательно, шарил по форуму, конечно... Но тем не менее проблему не решил. Помогите, ребят, пожалуйста!

=Aleks Versus=
Nex предлагал самый простой и наглядный способ организации времени. 
1. Вести подсчёт времени в одной переменной. Обычно никто не ведёт в текстовых играх подсчёт в секундах, так что самое меньшее дробление - минуты. Время в примере у Nexа считается именно в минутах. 
2. Всякий раз когда на действие тратится время изменяем значение переменной, которая отвечает за подсчёт 

время = время + 20 & !например 
! или 
минуты = минуты + 20 & ! если тебе так проще

3. Чтобы вывести текущее значение, сколько часов, дней и т.д прошло, используются усреднённые значения 
в одном часе 60 минут 
в одном дне 24 часа 
в одном месяце 30 дней 
в одном году 360 дней 
Надеюсь, теперь понятно, почему время/(24*60)= дни ? 

evp не так давно дал универсальную формулу Юлианского календаря. И объяснил, как им пользоваться. 

А строка, где присутствует оператор *pl - это просто вывод на экран. В твоём случае делается так, я полагаю: 

*pl '[<<день_недели>>], [Время:<<часы>>:<<минуты>>], [Дата:<<дни>>.<<$месяц>>.<<год>>]'

=Dower.Hollower=
т.е. счётчик у нас будет считать только в минутах, получается так? Значит если мне нужно начало игры 1 января 2015 года это будет: 2015*360*24*60=1044576000 минут? 
Следовательно у нас это число идёт в заданную переменную, затем прописываем код для дробления на часы/дни и т.д., а при действии добавляем определённое кол-во минут к уже заданной переменной, всё правильно понял?

=Aleks Versus=
правильно. Но тебе не обязательно делать счётчик от нуля. Можешь подсчитывать время с начала игры, а потом увеличивать на отсчётное значение. Допустим сколько лет прошло с начала игры +2015. Лично я так делал.

Так. Поправил календарик, кому ещё интересно. Проверил даты, потестил. Ничего не пропадает, стоически совпадают дни недели с датами действительного календаря. Так же для примера сделан календарь далёких родичей двемеров - недомеров, дабы показать, как легко и просто изменить данный календарь под свои нужды. 
Благодаря evp была выявлена глобальная ошибка, а так же упрощены некоторые вычисления. Спасибо. 
https://qsp.org/components/com_agora/img/members/248/calenda2.qsp 
-----------------------------------------------------------------------
=Svartberg=
https://qsp.org/index.php?option=com_agora&task=topic&id=40&p=148&prc=25&Itemid=57#p22333
Народ, у меня тут появилась задачка, с которой я, к сожалению справится все никак не могу... 
Хочу реализовать время проведенное в игре (общее число времени). Все это реализуется с помощью MSECSCOUNT. Но вот как это все будет работать я так и не разобрался. Мне нужны минуты и часы проведенные в игре. 
Если кто разбирается, помоги те пожалуйста.

=Aleks Versus=
тебе поможет $counter и пара переменных счётчиков. Поищи по форуму или почитай вот здесь https://qsp.org/index.php?option=com_content&view=article&id=111:-10&catid=36:2009-02-19-06-11-21&Itemid=76, как делается время в игре. Аналогичным образом сделай подсчёт реального времени. Я бы на локации counter сделал следующее: 

 Спойлер Show Spoiler Hide Spoiler
 
Код:
new_time = msecscount & ! текущее время 
past_time = last_time - new_time & ! сколько прошло с последнего посещения локации counter 
if past_time>0: 
! прошло более 0 мсек 
    time['msecs']+=past_time & ! текущее значение милисекунд 
    ! вычисляем добавочные секунды 
    time['addsecs']=time['msecs']/1000 
    ! перевычисляем текущее значение миллисекунд 
    time['msecs']=time['msecs'] mod 1000 
    
    ! вычисляем текущее значение секунд 
    time['secs']+=time['addsecs'] 
    ! вычисляем добавочные минуты 
    time['addminute']=time['secs']/60 
    ! перевычисляем текущее значение секунд 
    time['secs']=time['secs'] mod 60 
    
    ! вычисляем текущее значение минут 
    time['minute']+=time['addminute'] 
    ! вычисляем добавочные часы 
    time['addhour']=time['minute']/60 
    ! перевычисляем текущее значение минут 
    time['minute']=time['minute'] mod 60 
    
    ! вычисляем текущее значение часов 
    time['hour']+=time['addhour'] 
    ! вычисляем добавочные дни 
    time['addday']=time['hour']/24 
    ! перевычисляем текущее значение часов 
    time['hour']=time['hour'] mod 24 
    
    ! вычисляем текущее значение дней 
    time['day']+=time['addday'] 
    !.... и т.д. 
end 
! не забываем запоминать последнее зафиксированное значение времени прошедшего с начала игры 
last_time = new_time
---------------------------------------------------------------------------------------
=DeathSpace=
https://qsp.org/index.php?option=com_agora&task=topic&id=40&p=155&prc=25&Itemid=57#p22900
Ребят у меня такой вопрос, можно ли в классическом плеере(Например в окне доп описания)поставить реальное время компьютера?

=Svartberg=
Насколько я могу быть уверен  (99,99%), в классике нельзя это сделать. Однако ты можешь попросить игрока ввести время самому и плясать от этого

=Aleks Versus=
нет. Можно попробовать так: попросить игрока ввести точное время на старте игры, а потом вычислять текущее время исходя из введённого. Но никто вроде бы этого ещё не пробовал.
---------------------------------------------------------------------------------------
=Lexon=
https://qsp.org/index.php?option=com_agora&task=topic&id=40&p=160&prc=25&Itemid=57#p23235
Народ, подскажите как сделать так что бы голодал главный герой, что то никак не пойму, по идее надо просто прибавлять минуты, но я что то туплю. В техлоке как этот код прописать то ? 
Пробую методом тыка, а всё никак.

=Chaos Legion=
смотря как время реализовано. 
если абсолютное, то я делаю так: 

hunger -= current_time - hunger_lastcheck  !отнимаем кол-во пройденых минут от голода 
hunger_lastcheck = current_time            !обнуляем счетчик

=Oliver=
minuts+=1 
if minuts > 59: hour+=1&minuts = 0 
if hour > 24: day+=1&hour = 0 
if day > 31: weak+=1&day = 1 
if weak > 9: year+=1&weak = 1 
GS '#Weak' 
$hour = iif (hour<10, '0<<hour>>', '<<hour>>') 
$minuts = iif (minuts<10, '0<<minuts>>', '<<minuts>>')
#Weak 

Код:
$weak[1] = 'Ароса' 
$weak[2] = 'Новаса' 
$weak[3] = 'Огоса' 
$weak[4] = 'Латоса' 
$weak[5] = 'Дургоса' 
$weak[6] = 'Мелоса' 
$weak[7] = 'Назоса' 
$weak[8] = 'Ураса' 
$weak[9] = 'Анолзура'
Как выводить: 

Код:
*PL '<<day>> день <<weak>> месяца(<<$weak[weak]>>) <<year>> года <<$hour>>:<<$minuts>>'
Код:
IF hour > 15: $golod_step1 = 'Вы голодны!'
---------------------------------------------------------------------------------------
=cleep=
https://qsp.org/index.php?option=com_agora&task=topic&id=40&p=179&prc=25&Itemid=57#p24224
Здравствуйте, еще раз. Вопрос такой: могу ли я задать рандомное время, когда может случиться событие? Например, с 10 до 15 часов в дверь могут позвонить и т.д.

=Aleks Versus=
ты можешь всё.) 
Не ясно, в чём проблема. Заносишь заранее в переменную время, когда должно случиться событие: 

Код:
time_rndact = rand(10,15)
И проверяешь: 

Код:
if hour=time_rndact: 
! событие 
end
Где это писать? Первую часть можно в самом начале игры. Вторую -- там, где вычисляешь текущий час (hour).

---------------------------------------------------------------------------------------
=kolvados=
https://qsp.org/index.php?option=com_agora&task=topic&id=40&p=181&prc=25&Itemid=57#p24363
Люди добрые подскажите пожалуйста. 
Вопрос: как правильно привязать голод ко времени? Допустим, чтобы раз в час голод= - 1 ? (Всю голову себе уже сломал, хотя чувствую, что решение лежит на поверхности) 
У меня есть вот этот календарь: 

Код:
JDN = JDNStart + time/1440 
hour = (time/60) MOD 24 
minut = time MOD 60 
weekday = (JDN MOD 7) + 1 

JDa = JDN + 32044 
JDb = (4*JDa + 3)/146097 
JDc = JDa - (146097*JDb/4) 
JDd = (4*JDc + 3)/1461 
JDe = JDc - 1461*JDd/4 
JDm = (5*JDe + 2)/153 

day = JDe - (153*JDm+2)/5 + 1 
month = JDm + 3 - 12*(JDm/10) 
year = 100*JDb + JDd - 4800 + JDm/10 
$hour = iif (hour<10, '0<<hour>>', '<<hour>>') 
$minut = iif (minut<10, '0<<minut>>', '<<minut>>')

=cleep=
Лучше бы ты заменил код времени на более простой. Например: 
Код:
!!!Время 
!!минуты в часы 
:loopminute 
if minute>=60: 
     hour+=1 
     gs 'gs_время' 
     minute-=60 
     jump'loopminute' 
end 
!!часы в сутки 
:loophour 
if hour>=24: 
     day+=1 
     dayspast+=1 
     weekday+=1 
     hour-=24 
     jump'loophour' 
end 
!!Цикл дней недели 
:loopweek 
if weekday>7: 
     weekday-=7 
     jump'loopweek' 
end 
!!Дни в месяцы 
:loopmonth 
!это еще и годовая метка, ибо смена года влияет на високосность 
!Благодаря этому ифу, мы прервем конвертацию дней в месяцы, если месяцев набралось более чем на год. Сначла месяцы в год, потом возвращаемся снова к дням в месяцы. 
if month<13: 
     !Невисокосный февраль 
     if month=2 and day>28 and year mod 4!0: 
     month+=1 
     day-=28 
     jump'loopmonth' 
     end 
     !Високосный февраль 
     if month=2 and day>29 and year mod 4=0: 
     month+=1 
     day-=29 
     jump'loopmonth' 
     end 
     !Январь, март, май, июль, август, октябрь, декабрь 
     if (month=1 or month=3 or month=5 or month=7 or month=8 or month=10 or month=12) and day>31: 
     month+=1 
     day-=31 
     jump'loopmonth' 
     end 
     !Апрель, июнь, сентябрь, ноябрь 
     if (month=4 or month=6 or month=9 or month=11) and day>30: 
     month+=1 
     day-=30 
     jump'loopmonth' 
     end 
end 
!!месяцы в годы 
if month>12: 
     year+=1 
     month-=12 
     jump'loopmonth' 
end 
!Сопоставление текстового названия дня недели его числовому значению 
if weekday=1:$weekday='Понедельник' 
if weekday=2:$weekday='Вторник' 
if weekday=3:$weekday='Среда' 
if weekday=4:$weekday='Четверг' 
if weekday=5:$weekday='Пятница' 
if weekday=6:$weekday='Суббота' 
if weekday=7:$weekday='Воскресенье' 
!тоже самое, только для месяцев 
if month=1:$month='Января' 
if month=2:$month='Февраля' 
if month=3:$month='Марта' 
if month=4:$month='Апреля' 
if month=5:$month='Мая' 
if month=6:$month='Июня' 
if month=7:$month='Июля' 
if month=8:$month='Августа' 
if month=9:$month='Сентября' 
if month=10:$month='Октября' 
if month=11:$month='Ноября' 
if month=12:$month='Декабря' 
!преобразовывает, например, 9 часов в 09 часов 
if hour<10:$nullh='0' 
if hour>=10:$nullh='' 
!тоже самое, но для минут 
if minute<10:$nullm='0' 
if minute>=10:$nullm=''
Сам в начале работал с тем, что у тебя, но потом забил) 

Что касается убывания, то здесь: 

Код:
:loopminute 
if minute>=60: 
     hour+=1 
       gs 'gs_время' 
     minute-=60 
     jump'loopminute' 
end
В gs 'gs_время' прописываешь gg['голод']-=1 (или как там у тебя голод обозначается) и все должно работать 

P.S. Если решишь использовать этот код, то формат вывода: 
pl'Время <B><<$nullh>><<hour>></B>:<B><<$nullm>><<minute>></B>' 
pl'Сейчас <<day>> <<$month>> <<year>> года, <<$weekday>>.'

=kolvados=
Большое спасибо. Только не очень понятно что есть в данном раскладе 'gs_время', разве не в него мне надо весь этот код вмантировать? 
Есть еще одна проблема: если я захочу допустим "поспать в кровати" и пройдет не один час, а два но голод тем не менее отнимется все равно 1.

=cleep=
 Нет, у меня пока что в 'gs_время', прописано только gg['бодрость']-=3.  

Да, проблема есть. Но я бы решил ее так: 

Код:
     act 'Спать': 
               minute +=480 
               gg['Бодрость']=100 
               gg['голод']-=N 
         gt 'Кровать' 
         
То есть для каждого действия, где необходимо, чтобы голод снижался больше 1, можно назначить отдельный параметр. Хотя я почти уверен, что есть способ проще, но я его не знаю smile

=Aleks Versus=
схема календаря не важна, если игровое время считается в минутах. Оба кода (JDN и :loop) по факту пересчитывают все прочие значения исходя из прибавленного количества минут. Только последний код не использует переменную time для хранения игрового времени, прошедшего с начала игры, а сразу делает перерасчёт по всем значениям: часы, дни, недели. Оба этих кода будем называть календарями. 

Чтобы календарь создавал в игре правильное текущее время, необходимо выполнять его код всякий раз, когда время изменяется. Для первого календаря (JDN) необходимо изменять переменную time. Например: 

Код:
act 'Идти в гости к бабушке': 
     ! дорога до бабушки 2 часа 
     time = time + 2*60 
     ! здесь ставим код календаря 
end
Поскольку это очень громоздко (каждый раз при изменении времени воротить такой огромный код), календарь оформляют в отдельную локацию и вызывают через GOSUB (например календарь мы поместили на локации 'Календарь'): 

Код:
act 'Идти в гости к бабушке': 
     ! дорога до бабушки 2 часа 
     time = time + 2*60 
     ! вызываем календарь: 
     GOSUB 'Календарь' 
end
Для второго случая, где используются циклы (через метки :loop), то же самое можно записать так: 

Код:
act 'Идти в гости к бабушке': 
     ! дорога до бабушки 2 часа 
     minute = minute + 2*60 
     ! вызываем календарь: 
     GOSUB 'Календарь' 
end
или так 

Код:
act 'Идти в гости к бабушке': 
     ! дорога до бабушки 2 часа 
     hour = hour + 2 
     ! вызываем календарь: 
     GOSUB 'Календарь' 
end
Приблизительно такая же ситуация и с голодом. Вот уже пару недель перечитываю тему "Как сделать", и там этот вопрос раза три-то точно поднимался. 

Голод должен изменяться периодически, т.е. через равные промежутки времени его значение увеличивается (герой становится голоднее). Например, каждые двадцать минут на единицу. Но, время, которое герой тратит на действия не всегда кратно двадцати минутам, и это надо учитывать, "запоминая" остаток времени для пересчёта голода. 

Возьмём для примера два действия "Покрасить забор" (4 часа 43 минуты) и "Постоять потупить, глядя на часы, ровно 7 минут" (7 минут), и рассмотрим их в контексте календаря JDN. 
За четыре часа сорок три минуты герой успеет проголодаться на 14 единиц { (4*60 + 43)/20 }, но при этом останутся три неучтённые минуты. 
За 7 минут герой успеет проголодаться на 0 единиц { 7/20 } и останется 7 неучтённых минут. 

Исходя из этих двух случаев несложно составить маленький код, вычисляющий значение голода для двух конкретных действий: 

Код:
act 'Покрасить забор': 
     ! красим забор за 4 часа и 43 минуты 
     time = time + 4*60 + 43 
     ! вызываем календарь: 
     GOSUB 'Календарь' 
     ! считаем голод 
     голод = голод + (4*60 + 43 + голод_остаток)/20 
     ! запоминаем остаток минут, чтобы добавить в другой раз 
     голод_остаток = (4*60 + 43 + голод_остаток) MOD 20 
end
Код:
act 'Постоять потупить, глядя на часы, ровно 7 минут': 
     ! стоим тупим семь минут 
     time = time + 7 
     ! вызываем календарь: 
     GOSUB 'Календарь' 
     ! считаем голод 
     голод = голод + (7 + голод_остаток)/20 
     ! запоминаем остаток минут, чтобы добавить в другой раз 
     голод_остаток = (7 + голод_остаток) MOD 20 
end
Как мы видим, из действия в действие код повторяется, а значит его можно вынести в отдельную локацию, а потом просто обращаться к ней по GOSUB, чтоб не писать один и тот же код всякий раз. Но, в разных действиях у нас разные значения. В "покрасить забор" -- одно, в "постоять потупить" -- другое. Как быть? 
Всё очень просто. Дело в том, что локация может получать несколько значений и хранить их ровно то время, пока выполняется её код. Для передачи значения, нужно указать его через запятую после названия локации, например: 

Код:
GOSUB 'улётная_лока',455
Чтобы использовать это значение на локации, берём специальные переменные args[], значения которых работают только на этой конкретной локации. На всех других локациях значения переменных args[] будут другими. Применим это знание к нашему коду. Создаём локацию "изменение_времени": 

Код:
!#изменение_времени 
     ! вызывать например так GOSUB 'изменение_времени',7 
     args[0]=args[0] & ! значение этой переменной для примера равно 7. См. строку выше 
     ! изменяем время 
     time = time + args[0] 
     ! вызываем календарь: 
     GOSUB 'Календарь' 
     ! считаем голод 
     голод = голод + (args[0] + голод_остаток)/20 
     ! запоминаем остаток минут, чтобы добавить в другой раз 
     голод_остаток = (args[0] + голод_остаток) MOD 20 
end
Теперь переписываем действия "покрасить забор" и "постоять" согласно нашей новой локации: 

Код:
act 'Покрасить забор': 
     ! красим забор за 4 часа и 43 минуты 
     GOSUB 'изменение_времени',(4*60 + 43) 
end
Код:
act 'Постоять потупить, глядя на часы, ровно 7 минут': 
     ! стоим тупим семь минут 
     GOSUB 'изменение_времени',7 
end
Всё чертовски упростилось, не правда ли? 

P.S.: Для календаря с loop вместо time нужно использовать minute. Числовые значения будут те же.

=kolvados=
Благодарю за столь подробное разъяснение сия вопроса. 
Но тем не менее вопрос встречный: (несколько раз перечитал сообщение) но так и не понял откуда берется голод_остаток в смысле как вычисляется?

=Aleks Versus=
это остаток от деления времени, которое потрачено на действие, на время, которое требуется, чтобы голод увеличился на единицу. 

В примере голод возрастает на 1 каждые двадцать минут. Поэтому, если на действие тратится 4 часа 43 минуты (283 минуты), то за это время голод возрастёт на 14 единиц и ещё 3 минуты останутся неучтёнными. Их записываем в голод_остаток. При следующем действии в вычислении нам необходимо приплюсовать этот остаток к потраченному на действие время, чтобы учесть. Поэтому голод_остаток я сразу вставил в формулу.

Возможно это не слишком удачное название переменной. Но называть её неучтённое_время_на_голод слишком громоздко. 

Остаток от деления вычисляется оператором MOD 

283 MOD 20 = 3 
7 MOD 20 = 7 
20 MOD 20 = 0 

в QSP эквивалентно: 
283 - (283/20)*20

=kolvados=
Вопрос в другом. Т.к. в коде никак не прописывается то, что остаток от деления присваивается этой переменной, мне не понятно это делает сама программа или я сам в ручную должен это сделать?

=Aleks Versus=
как это не прописывается? 

голод_остаток = (7 + голод_остаток) MOD 20

Действия игроком могут выполняться в произвольном порядке. Если он выберет "покрасить забор" а потом "потупить" произойдёт следующее: 
в действии "покрасить забор" будет вычислен голод и остаток времени (голод_остаток) равный 3 минуты. 
в действии "потупить" нужно учесть этот остаток. Поэтому он сразу вставлен в формулу и прибавляется к тем семи минутам, что мы тратим на действие "потупить". 

Но если действия будут выполняться игроком в обратном порядке, то сначала будет выполнено действие "потупить" и в остаток запишется 7 минут. Когда игрок выберет "покрасить забор", нужно прибавить эти семь минут ко времени на действие, поэтому остаток тоже заранее внесён в формулу. 

P.S.: Мне казалось, это очевидно, но очевидно не очевидно. )) Надо будет учесть.

=kolvados=
Спасибо. Видимо я продолжаю тупить вместо того, чтобы красить забор.
---------------------------------------------------------------------------------------
=Enklaver=
https://qsp.org/index.php?option=com_agora&task=topic&id=40&p=187&prc=25&Itemid=57#p24632
Сделал время как в примере -Календарь по методу счёта Юлианских дней 
https://qsp.org/index.php?option=com_agor … ;Itemid=57 
Сделал время при переходе на другие локации и т.д. 
но вот ни как не могу придумать как сделать чтобы к примеру локация "МАГАЗИН" работала в будни с 8 до 21

=Svartberg=
с помощью условий. 
К примеру: 
  Установить условеие при котором в промежутке; IF hour >= 8 and hour < 21 
  Ну и так же указываешь условие при котором в выходные дни магазин тоже не будет работать. 
  И просто указываешь, что ссылка будет активной при этом условии. Вот и всё.
---------------------------------------------------------------------------------------
=Сергей=
https://qsp.org/index.php?option=com_agora&task=topic&id=40&p=188&prc=25&Itemid=57#p24753
С горем пополам прикрутил время и календарь. Время меняется при переходах. А как теперь сделать постоянно идущее время, независимое от действий? Но так чтобы часы , дни недели и календарь остались и время можно было поменять из строки ввода.

=Nex=
делай увеличение времени в COUNTER.
---------------------------------------------------------------------------------------
=Сергей=
https://qsp.org/index.php?option=com_agora&task=topic&id=40&p=188&prc=25&Itemid=57#p24759
Подскажите, пожалуйста, как ограничить число посещений локации за день . Т.е. 3 раза зашёл - запрет , день сменился - можно опять 3 раза зайти .Календарь вот такой: 
clr 
!Время! 
:minutplus 
     if minut<55: 
     minut=minut+5 
     if minut=55: 
     minut=minut+4 
end 
if minut>55: 
minut=minut=0 

     set hour+=1 
     set bodro=bodro+10 
end 
:hourplus 
if hour>=24: 
     set day+=1 
     set week+=1 
     set hour-=24 
     if hour>=24:jump'hourplus' 
end 
:weekplus 
if week>7: 
     set week-=7 
     if week>7:jump'weekplus' 
end 
if day>31:set month+=1 & set day-=31 
if month>12:set year+=1 & set month-=12 

В стартовой локации прописано: 
$ONNEWLOC='stat'

=St-john=
Ну как вариант: 
Код в локации, в которую 3 раза заходишь: 

Код:
Perem_zahod+=1
Код в локации, откуда заходишь: 

Код:
act 'Перемещение в нужную локацию': 
If Perem_zahod<3: goto 'Нужная локация' 
end
Код в локации 'stat': 

Код:
if day-day_last>0: Perem_zahod=0 
day_last=day
---------------------------------------------------------------------------------------
=DeathSpace=
https://qsp.org/index.php?option=com_agora&task=topic&id=40&p=197&prc=25&Itemid=57#p25188
Всем привет, хочу сделать такую систему: 
У меня есть полоска голода допустим в ней 100 единиц, она тратиться за 4 часа т.е. 100/240 минут= 0,41 единица на 1 минуту времени. 
Так вот я хочу чтобы как только время в игре поменялось например: прошло 5 минут minute+=5 из полоски голода [100 единиц] сразу вычитались единицы голода 
Сейчас же мне приходиться проводить вычитания голода только каждый час. 

if minut >= 60: 
  :min 
  phun = 100 - ((100/240*minut)/1) 
  set minut -=60 
  set hour += 1 
  if energy >= 1:set energy -= 1 
  php += pmaxhp/10 
  if minut >=60:jump 'min' 
end

=Aleks Versus=
100 единиц на 240 минут, это 5 единиц здоровья на 12 минут. Если делать целыми числами, единственный вариант вычитать по пять единиц каждые двенадцать минут. Делается это достаточно просто. 
1. проверяем, прошло ли за этот ход требуемое количество времени. 
2. если прошло времени больше или равное требуемому, вычисляем, насколько изменился голод (phun). 
3. остаток времени, записываем в специальную переменную, чтобы на следующий ход учесть его. 
Итак, нам понадобятся три переменные time_golod — цена времени для эффекта голода (12 минут), pow_golod — сила голодания для эффекта голода, и ost_golod — остаток времени для учёта. Пишем программу соответственно созданному алгоритму: 

Код:
!1 
! time — переменная time для наглядности, она показывает, сколько всего минут потрачено на ход 
if time + ost_golod >= time_golod: 
   !2 скобки вокруг деления для наглядности 
   phun = phun - ((time+ost_golod)/time_golod)*pow_golod 
   !3 
   ost_golod = (time+ost_golod) mod time_golod 
end
---------------------------------------------------------------------------------------
=WastedCarl=
https://qsp.org/index.php?option=com_agora&task=topic&id=40&p=207&prc=25&Itemid=57#p26199
Можете ли подсказать как сделать чтобы часы (время в игре) перемещались в каждой локации. 
Ну то есть в одной локации 14:00,переместился в другую локацию там уже 14:10,но при этом оператор на время во второй локации писать не нужно

=Nex=
чтобы на второй локации не писать, прибавляй время на первой перед переходом. 

ACT 'Идти в школу' 
    время = время + 10 
    GOTO 'Школа' 
END
Ну а в целом время с примерами смотри здесь - Игровое время
---------------------------------------------------------------------------------------
=Freem82=
https://qsp.org/index.php?option=com_agora&task=topic&id=40&p=214&prc=25&Itemid=57#p26762
Здравствуйте. Подскажите, пожалуйста, как сделать реальный таймер с подсчетом минут и секунд. Пример (как я вижу): 
'До окончания задания осталось <<minut>> минут: <<sec>> секунд' 
'Прошло время от начала задания <<minut>> минут: <<sec>> секунд' 
'Вы выполнили задание за <<minut>> минут: <<sec>> секунд' 
'Вы провели в игре <<minut>> минут: <<sec>> секунд' 
Спасибо заранее за ответ.

=Aleks Versus=
Вот в этой теме должен быть ответ на твой вопрос https://qsp.org/index.php?option=com_agora&task=topic&id=1217&Itemid=57

Чтобы делать обратный отсчёт, нужно просто фиксировать время в переменных. 

Код:
! Выставляем пороговое время задания в переменных minut_quest и sec_quest, тогда: 
'До окончания задания осталось <<minut_quest-minut>> минут: <<sec_quest-sec>> секунд' 
! Фиксируем время начала задания в minut_start, sec_start, тогда: 
'Прошло время от начала задания <<minut-minut_start>> минут: <<sec-sec_start>> секунд'
И т.д. 

По хорошему надо переводить минуты-секунды в секунды, вычислять разницу, потом обратно секунды в минуты-секунды.

=ejikplains=
Все намного проще. Для ввода разного порядка времени тебе понадобится локация обработчик(см. вики counter), в которой будет реализован алгоритм времени от нуля к бесконечности и от какого-либо промежутка времени до нуля. 
Создаешь локацию и называешь её counter 
В данной локации вставляешь код: 

Код:

sec = sec - 1 
if sec = -1: 
    min = min - 1 
    sec = 59 
    gt curloc 
end 
if min = -1: 
gt 'переход в локацию, если время вышло' 
end 
gt curloc 
Выше локация обратного отсчёта. До перехода на локацию, где будет отсчёт, нужно задать количество минут и секунд, которое необходимо на локации 

Код:

min = 2 
sec = 0 
(это две минуты) 
А в основной локации нужно дописать в конце код, представленный ниже. 

Код:

settimer 1000 
$COUNTER = 'counter1' 
где, settimer - периодичность запуска локации counter1 в миллисекундах(у нас 1000 = 1 секунда, т.е. раз в секунду). 

Для ввода отсчёта с нуля, снова вводим локацию обработчика, назовем её по другому(чтоб не путаться) - counter2, но уже с другим кодом, представленным ниже: 

Код:

sec1 = sec1 + 1 
if sec1 = 60: 
    sec1 = 0 
    min1 = min1 + 1 
end 
gt curloc 
В этот раз нам не нужны данные до входа на локацию. Просто в конце локации, где идёт отсчёт времени вперёд, добавляем уже знакомый код: 

Код:

settimer 1000 
$COUNTER = 'counter2' 
Далее выводишь в основном окне показатели времени. Если у тебя уменьшается время, то 
"осталось <<min>> минут <<sec>> секунд" 
если увеличивается, то: 
"прошло <<min1>> минут <<sec1>> секунд" 
... 
Примечания: 
1)не забывай останавливать таймеры, когда они не будут нужны. Остановить таймер можно одним из вариантов(для меня он более простой) кода, представленным ниже: 

Код:

a = 0 
if a = 0: 
    settimer 1000 
    $COUNTER = 'counter1' 
    a = a + 1 
end 
Более подробную информацию можешь получить из поста Alex Versus с ответом на твой же вопрос выше.
---------------------------------------------------------------------------------------
=Freem82=
https://qsp.org/index.php?option=com_agora&task=topic&id=40&p=216&prc=25&Itemid=57#p26866
Извините, что по новой с этим вопросом. Как отобразить результат времени. Постараюсь попроще 
На пример: Задача - отожмись 10 раз за определенное время время "Старт" (запускаем таймер для его отключения нажмите на ссылку) 
Отжались нажимаем на ссылку переходим на другую локацию результата "нет", если зациклили время в противном случае он будет все время бежать дальше. 
Через разные функции пробовал, всего "сапера" перековырял(честно так и не понял как он запоминает время окончания(вернее частично так, как этот способ мне несильно подходит))

=Aleks Versus=
Приблизительно так. Создаём локацию, например с именем "таймер". Указываем плееру в самом начале игры, что это локация-счётчик: 

Код:
$counter="таймер"
Там же задаём периодичность выполнения кода на этой локации 

Код:
settimer 20 & ! каждые 20 мс
На самой локации "таймер" пишем что-то типа: 

Код:
if timer_start=1: 
    ! таймер работает как правило с небольшими значениями 
    ! поэтому достаточно писать только милисекунды 
    msecs+=20 
    ! для отображения секунд минут и прочего, просто делаем персчёт 
    secs=msecs/1000 
    msecs_mod=msecs-secs*1000 
    mins=secs/60 
    secs=secs-mins*60 
    hour=mins/60 
    mins=mins-hour*60 
    ! и т.д. 
    clr 
    pl "<<hour>>:<<mins>>:<<secs>>.<<msecs_mod>>" 
end
Действия для проверки: 

Код:
act "запустить таймер": 
    timer_start=1 
end 
act "остановить таймер": 
    timer_start=0 
end 
act "сбросить таймер": 
    msecs=0 
    secs=0 
    mins=0 
    hour=0 
    ! и т.д. 
end 
act "нужно кликнуть десять раз": 
    click+=1 
    if click=10: 
        timer_start=0 
        time_msecs=msecs 
    end 
    if time_msecs>2000: "Вы не уложились во время" 
end
Думаю, допилишь, как тебе нужно.