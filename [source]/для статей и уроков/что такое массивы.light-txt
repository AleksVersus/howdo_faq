что такое массивы
----------------------------------------------------------------------------
=IceMan=
http://qsp.su/index.php?option=com_agora&task=topic&id=40&p=183&prc=25&Itemid=57#p24508
Народ такой вопрос. В игре предмет лежит ну на столе допустим. С ним можно сделать два дела... допустим лежит телефон в него можно поиграть и можно просто положить в карман. после того как ложишь в карман одно действие пропадает соответственно потому что в инвентаре телефон = 1 стал). поиграть в телефон не пропадает. Delact 'Поиграть в телефон'  игнорит в условии нафиг... как будто его там и нет. 

*две минуты спустя* 
я просто затупок извиняйте))) 3 часа ночи нашел в чем проблема... теперь второй вопрос как можно сделать так что бы допустим в одной локации у тебя были одни предметы, когда ты выходишь в другую локацию у тебя другие предметы... но если вернешся обратно в прежнюю локацию опять же вернутся теже предметы... что бы предметы как бы были у тебя но и в тоже время были привязаны к определенным локациям.

=Nex=
сохраняй предметы в массив по имени лоакции, загружай их из массива аналогично.

=IceMan=
в том то и проблема что у меня с массивами полная беда... я сколько не патался через дрегие игры разобратся. я тупо не могу понять в них что к чему относится... какой код какое действие выполняет (кроме простейгшихтипо переходов в локации, взять предмет использовать предмет, диолог и т.д) остальное огромная беда.

=Aleks Versus=
http://aleksversus.narod.ru/index/peremennye_i_massivy_v_qsp/0-28
---------------------------------------------------------------------------------------
=mkir=
http://qsp.su/index.php?option=com_agora&task=topic&id=40&p=204&prc=25&Itemid=57#p25896
Друзья, пожалуйста! Я уже не один раз спрашивал что-нибудь касаемо массивов и всякий раз мне подробно и замечательно всё объясняли. Но всякий раз я всё равно ничего не понимал. Ну, вот не идут они у меня и всё. А хочется развиваться) Никакие справочные материалы тоже не помогают. Хотя я пытался, честно. 

Вот, например, я хочу сделать что-то вроде презентации настольной карточной игры для одной компании. Т.е. объяснить как она работает. Qsp бы идеально подошло, но без массивов тут очень сложно... Вот, например, пункты важные для этого дела: 
1. Есть три типа колоды. Есть карта с десятью "локациями". Из колоды А нужно раздать всем игрокам (до от 3-х до 6-ти человек), допустим, по три карты. Как это сделать? 
2. Оставшиеся карты из колоды А и все карты из колоды Б, нужно равномерно распределить на "Локациях" и запомнить, что где, в каком порядке расположено. 
3. Игрок попавший на определенную локацию, может взять карту и получает "верхнюю", а не в случайном порядке. 
4. Колода В - содержит "штрафные" карты, которые игроки получают за те или иные неправильные действия. Карты из этой колоды распределены по типам. То есть у каждой есть такое свойство как "тип". И наличие карт одного типа - больше штрафных очков. От этого будут зависеть действия всех игроков. То есть каким-то образом нужно присвоить таким картам подобное дополнительное качество. 
5. На игровом экране должно быть какое-то поле, где можно было бы увидеть, какие карты колоды А у каких игроков есть. Думаю, обойдусь без картинок, но будут имена этих карт с возможностью посмотреть подробнее при нажатии на имя (это я понимаю, как сделать). Но не понимаю, как организовать пространство, как "складировать" в эти поля имеющиеся карты. 

Если объясните подробно хотя бы эти моменты, со скидкой на моё тугоумие, на первое время для переваривания мне хватит. Надеюсь, что хоть что-то понятно, очень мутно объясняю, но не знаю как по-другому. Что-то я почерпнул из игры "Девятка" от автора Snail. Очень полезно оказалось, однако всё равно многое не переваривается. 
Надеюсь на понимание)) На этом форуме я его нахожу всегда))

=Wol4ik=
Мне кажется это математические задачи на сортировку массивов, программирование лишь реализует алгоритмы, которые являются решениями этих задач. То есть знание QSP поможет здесь не больше, чем чего-либо другого. 

Можно начать с того, что каждой карте присвоить номер y1,y2,y3,y4 и тд. Желательно подряд. Ноль не занимать. Одномерный массив объемом Х, где Х это количество видов карт. Сделать А = RАND (1,Х), и в эту случайную ячейку А вписывать очередной "y", получаемый при помощи цикла. И дать условие IF, не вписывать в ячейку игрек, если ее значение не равно нулу, то есть она уже занята. То есть значения игреков будут идти подряд - 1,2,3,....х , а их местро хранения в массиве будет случайным. Когда будет вписан последний игрек в последнюю не занятую ячейку, тогда программа заканчивается, если игрек больше чем икс. Этот алгоритм "грязный", и ресурсоемкий, но другого я не знаю.

=mkir=
на странице "Разработчикам" http://qsp.su/index.php?option=com_content&view=article&id=57&Itemid=56 я когда-то выложил пример кода как раз для этого случая. 

Выбор случайных вариантов: тянем карты из колоды http://qsp.su/index.php?option=com_content&view=article&id=114:-10&catid=36:2009-02-19-06-11-21&Itemid=76

В общем-то все перечисленное - это классические задачи на массивы и циклы. Думаю, тебе лучше скооперироваться с кем-то, кто поможет весь базовый код написать от и до.

=Aleks Versus=
На самом деле всё с массивами очень просто. 

Массив — это ящик, в котором есть много-много ячеек. 

Каждая ячейка может содержать лишь одно значение. 

Чтобы получить значение определённой ячейки, нужно указать её номер (да-да, в квадратных скобках. Очень легко запомнить, потому что квадратные скобки по форме напоминают ящик). 

Нумерация ячеек всегда ведётся с нуля. 

Размер массива — это число ячеек до последней занятой. 

Таким образом, номер последней ячейки всегда можно узнать так:

Код:
номер_последней_ячейки = размер_массива - 1
В принципе, этого должно хватить для большинства игр, тем более с картами. 

Первая задача. 

 Спойлер Show Spoiler Hide Spoiler
  
Как бы я начал. Во-первых, колода. Колода А. Представим новую, нераспакованную колоду в 54 карты. Где она лежит? В футляре, в коробке, в ящике. Каждая карта в этом ящике занимает строго своё место — абстрактную ячейку. Таким образом колоду можно написать так: 
Код:

! обрати внимание, нумерация начинается с нуля 
$deck_a[0] = 'двойка треф' 
$deck_a[1] = 'тройка треф' 
$deck_a[2] = 'четвёрка треф' 
! и так далее до 54-й карты, которая лежит в ячейке с номером 53 
$deck_a[53]='чёрный джокер' 
Теперь из этой колоды выдаём карты игрокам. Число игроков пока ограничим двумя, для наглядности. 

В любой карточной игре игрок может держать в руке некоторое количество карт (иногда сколько угодно). У нас — три, согласно условиям задачи. 
В колоде (массив $deck_a) карта занимает ровно одну ячейку. Логично предположить, что и в руке карта занимает примерно столько же. Значит рука — это тоже массив. 

Код:

! рука первого игрока — массив $hand_1 
! у нас есть 54 ячейки в массиве $deck_a с номерами от 0 до 53 
! что мы можем? Можем получить случайное число от 0 до 53 
! но 53 — это номер последней ячейки, а он, как известно, вычисляется из размера массива. 
! значит мы выбираем случайное число от 0 до номера последней ячейки массива 
i_rand=rand(0,arrsize('$deck_a')-1) 
! делаем мы это не просто так. Далее мы в этом убедимся 
! Итак. Вкладываем карту в руку игроку. 
$hand_1[0]=$deck_a[i_rand] 
! теперь, чтобы карта больше не попадалась в колоде, убираем её. Вместе с ячейкой 
killvar '$deck_a',i_rand 
! номера ячеек при этом реорганизуются. Если мы выбросили 6-ю, то 7-ая станет 6-ой, восьмая — седьмой и т.д. 
! а последняя будет под номером 52 
! вот для чего мы используем формулу arrsize('$deck_a')-1, чтобы вычислить номер последней ячейки и не забивать 
! лишними цифрами голову 
! следующая карта 
i_rand=rand(0,arrsize('$deck_a')-1) 
$hand_1[1]=$deck_a[i_rand] 
killvar '$deck_a',i_rand 
! видим, что операции повторяются, меняется только номер ячейки для руки. Но добавим и третью карту 
i_rand=rand(0,arrsize('$deck_a')-1) 
$hand_1[2]=$deck_a[i_rand] 
killvar '$deck_a',i_rand 
! Вот так. Три карты уже есть у первого игрока, и мы видим, что записи повторяются, можно сделать цикл 
! для второго игрока так и сделаем 
i=0 & ! счётчик и одновременно номера ячеек в руке второго игрока 
:for 
if i<3: 
! если число i меньше 3 
    ! находим случайную карту в колоде 
    i_rand=rand(0,arrsize('$deck_a')-1) 
    ! добавляем карту в руку 
    $hand_2[i]=$deck_a[i_rand] 
    ! выбрасываем карту из колоды, вместе с ячейкой 
    killvar '$deck_a',i_rand 
    ! увеличиваем значение счётчика 
    i+=1 & ! это то же самое, что i=i+1 
    ! повторяем процедуру 
    jump 'for' 
end 
Первая задача решена. Думаю не составит труда проделать то же самое для других игроков. 

Если число игроков неизвестно заранее (например, выбирается случайным образом, или иным), можно воспользоваться оператором dynamic 

Код:

np_rand=rand(3,6) & ! число игроков (определили случайным образом) 
np=1 & ! номер игрока и счётчик внешнего цикла 
:for_n 
if no np>np_rand: 
! пока номер игрока не превысит число игроков 
    ! выполняем раздачу карт через dynamic 
    dynamic "! это код, который будет выполнять оператор dynamic 
    ! перед выполнением, вместо <<np>> будет подставлено число 
    i=0 & ! счётчик и одновременно номера ячеек в руке игрока номер np 
    :for_i 
    if i<3: 
        ! если число i меньше 3 
        ! находим случайную карту в колоде 
        i_rand=rand(0,arrsize('$deck_a')-1) 
        ! добавляем карту в руку игроку номер np 
        $hand_<<np>>[i]=$deck_a[i_rand] 
        ! выбрасываем карту из колоды, вместе с ячейкой 
        killvar '$deck_a',i_rand 
        ! увеличиваем значение счётчика 
        i+=1 & ! это то же самое, что i=i+1 
        ! повторяем процедуру 
        jump 'for_i' 
    end" 
    ! увеличиваем счётчик внешнего цикла 
    np+=1 
    ! повторяем 
    jump 'for_n' 
end 
Это всё не сложно и не громоздко. Просто я написал очень много комментариев. Если их удалить, код раздачи карт в руки займёт с десяток строк. 
---------------------------------------------------------------------------------------
=D31M0S=
http://qsp.su/index.php?option=com_agora&task=topic&id=40&p=207&prc=25&Itemid=57#p26267
Ребята, что за фигня эти "массивы" и как их использовать? Я кучу времени копаюсь в коде разных игр, и часто вижу их.

=Aleks Versus=
http://aleksversus.narod.ru/index/peremennye_i_massivy_v_qsp/0-28
-----------------------------------------------------------------------------------
=новичок=
http://qsp.su/index.php?option=com_agora&task=topic&id=40&p=217&prc=25&Itemid=57#p26994
объясните тупому про массивы и как их использовать. читаю про них и никак не пойму

=Aleks Versus=
У меня на сайте есть небольшая статейка про переменные и массивы. http://aleksversus.narod.ru/index/peremennye_i_massivy_v_qsp/0-28 

Переменная — это тумбочка с одним ящиком. Ты можешь положить в неё одно значение. 
Массив — это большой шкаф со множеством ящиков. В массиве можно хранить много значений. 

Чтобы работать с переменной, мы просто указываем её название, например: 

Код:

! в переменную ЯБЛОКО помещаем значение 1 
яблоко=1
Чтобы работать с массивом, нам нужно указать не только название массива, но и номер ящика/ячейки, в которой хранится значение: 

Код:
! в третью ячейку массива ЯБЛОКО помещаем значение 1 
яблоко[3]=1
Массивы удобны, когда нужно хранить множество подобных значений. Например, список месяцев в привязке к номерам: 

Код:
$месяц[0]="Январь" 
$месяц[1]="Февраль" 
$месяц[2]="Март" 
$месяц[3]="Апрель" 
$месяц[4]="Май" 
$месяц[5]="Июнь" 
$месяц[6]="Июль" 
$месяц[7]="Август" 
$месяц[8]="Сентябрь" 
$месяц[9]="Октябрь" 
$месяц[10]="Ноябрь" 
$месяц[11]="Декабрь"
Если использовать текстовые индексы (номера ячеек) вместо числовых, можно расширить возможности массива. Так например, можно хранить количество дней для каждого месяца: 

Код:
месяц_дней["Январь"]=31 
месяц_дней["Февраль"]=28 
месяц_дней["Март"]=31 
месяц_дней["Апрель"]=30 
месяц_дней["Май"]=31 
месяц_дней["Июнь"]=30 
месяц_дней["Июль"]=31 
месяц_дней["Август"]=31 
месяц_дней["Сентябрь"]=30 
месяц_дней["Октябрь"]=31 
месяц_дней["Ноябрь"]=30 
месяц_дней["Декабрь"]=31

=Aleks Versus=
Что значит вызвать? Получить значение из определённой ячейки? 

Код:
ИМЯ_МАССИВА[НОМЕР_ЯЧЕЙКИ]
Если тебе нужно вывести, скажем, все элементы массива, нужно использовать цикл: 

Код:
i=0 
:for 
if i<arrsize('$месяц'): 
! пока значение счётчика меньше размера массива 
   ! выводим ячейку под номером i на экран 
   *pl $месяц[i] 
   ! увеличиваем значение счётчика 
   i=i+1 
   ! повторяем/прыгаем на метку for 
   jump 'for' 
end