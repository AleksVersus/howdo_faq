
[Назад: Служебные локации](help:service_locations)

==Динамический код==
[:help_dynamical]

[:dinamicheskij_kod]

=Лирическое вступление, поясняющее, для чего может пригодиться динамический код=

Вы могли заметить, что язык QSP лишён некоторой гибкости, присущей другим языкам программирования. А могли, конечно, и не заметить. Например, если вам нужно вывести на печать массив, вы делаете это с помощью цикла:

```qsp
! массив mass создан заранее
loop local i,size=0,arrsize('mass') while i<size step i+=1:
	*pl mass[i]
end
```

Но, что если вам нужно вывести на печать десять массивов? Писать на каждый массив по циклу?

Гораздо проще написать одну универсальную локацию-функцию (см. раздел ["Пользовательские функции и процедуры"](help:organizing)), передавать в неё название массива и выводить одним и тем же циклом на печать любой массив.

И вот для этого нам и потребуется использовать динамический код.

(на самом деле у этой задачи есть решение и без применения оператора `DYNAMIC`, но нас сейчас интересует именно динамический код, поэтому продолжим в рамках нужного для примера решения).

Динамический код — это код, который мы не знаем заранее. Мы пишем лишь его составные части, а уже при выполнении программы этот код составляется из этих частей в нужные комбинации.

Прежде всего стоит спросить себя, из чего состоит любой код? И, кажется, что ответ очевиден: код состоит из команд. Это верно, но чем по сути являются команды? А вот тут ответ очевиден не для всех: команды — это строки текста.

А мы с вами прекрасно умеем работать со строками. Если не умеем, то быстренько прочтём раздел ["Строки"](help:strings) и тут же научимся.

Строки можно склеивать, в них можно встраивать подвыражения, из них можно вырзать фрагменты. Вот и с кодом по сути можно делать то же самое. Так давайте запишем наш цикл в виде строки:

```qsp
"loop local i,size=0,arrsize('mass') while i<size step i+=1:
	*pl mass[i]
end"
```

Что мы тут видим? А видим мы, что в этой строке прописано название массива `mass`, аж целых два раза. Название массива — это значение, которое можно помещать в перемнную, а можно извлекать из переменной. Например, мы поместили название массива в переменную `$array_name`. Как нам вставить значение этой переменной в наш код, записанный в виде строки? Используем подвыражения:

```qsp
$array_name='mass'
"loop local i,size=0,arrsize('<<$array_name>>') while i<size step i+=1:
	*pl <<$array_name>>[i]
end"
```

Если мы запустим этот код, мы увидим на экране код нашего цикла с массивом `mass`. Если мы пропишем в переменную `$array_name` название другого массива, и снова запустим код, мы увидим на экране тот же цикл, но с другим массивом. Это значит, что наша строка текста формируется `динамически`! То есть и код цикла формируется динамически. Нам осталось только научиться запускать на выполнение такой код, записанный в виде строки текста. И вот для этого как раз в QSP есть специальный оператор: `DYNAMIC`. Мы просто передаём этому оператору наш записанный в виде текста цикл, и оператор `DYNAMIC` легко его выполняет, как обычный код QSP:

```qsp
$array_name='mass'
dynamic "loop local i,size=0,arrsize('<<$array_name>>') while i<size step i+=1:
	*pl <<$array_name>>[i]
end"
```

Таким образом, заменяя значение в переменной `$array_name`, мы легко выводим на печать любой массив. А чтобы нам было ещё проще, мы создаём специальную локацию-функцию, которой будем передавать названия массивов, которые хотим распечатать. Назовём эту локацию `print_array`:

```qsp
!# print_array
dynamic "loop local i,size=0,arrsize('<<$args[0]>>') while i<size step i+=1:
	*pl <<$args[0]>>[i]
end"
```

И теперь как мы выведем на печать любой, какой хотим, массив? Проще простого:

```qsp
@print_array('mass')
@print_array('$unit_name')
@print_array('unit_count')
```

Вот так возможность работы с динамическим кодом позволяет нам сделать наш код QSP более гибким и легко читаемым.

=DYNAMIC=


	*  `DYNAMIC ` [$код]`,`[параметр 1]`,`[параметр 2]`, …` - выполняет код, указанный в виде строки текста. Выполнение кода [$код] здесь аналогично оператору GS:
		*  Код, переданный оператору `dynamic`, выполняется в виде отдельного блока кода, в который можно передавать параметры (аргументы).
		*  Переданные параметры хранятся в массиве ARGS. Максимальное количество параметров - `9`[1)](#fn__1).
		*  После выполнения старые параметры ARGS восстанавливаются. То есть внутри выполняемого кода `dynamic` используется свой собственный массив ARGS, его значения не пересекаются со значениями ARGS на локации, из которой `dynamic` был вызван.
		*  Затем продолжается выполнения программы со следующей команды после `dynamic`.
		*  Примеры:
```qsp

DYNAMIC '$a="string<<$b>>"'
DYNAMIC '$a'
DYNAMIC 'if $a="string":''text!'''
DYNAMIC "
$args[0]
addobj $args[1]
",'Вы взяли вилку.','Вилка'

```

	*  `DYNEVAL(`[$код]`,`[параметр 1]`,`[параметр 2]`, …)` - выполняет код, указанный в виде строки текста, с получением результата. Выполнение кода [$код] здесь аналогично оператору FUNC:
		*  Код, переданный функции `dyneval`, выполняется в виде отдельного блока кода, в который можно передавать параметры (аргументы).
		*  Переданные параметры хранятся в массиве ARGS. Максимальное количество параметров - `9`[2)](#fn__2).
		*  Результат функции равен значению $RESULT при возврате строкового значения, или RESULT при возврате числового значения. 
		*  Если при выполнении кода были установлены и RESULT, и $RESULT, то предпочтение отдаётся строковому значению. 
		*  После выполнения кода предыдущие значения ARGS и RESULT восстанавливаются. То есть внутри выполняемого кода `dyneval` используется свои собственные массивы ARGS и RESULT, и их значения не пересекаются со значениями ARGS и RESULT на локации, из которой `dyneval` был вызван. 
		*  `Внимание:` при использовании в коде [$код] операторов GS/DYNAMIC переменные RESULT и $RESULT могут перезаписываться кодом, выполняемым этими операторами.
			*  Исправлено в более новых версиях интерпретатора.
		*  Примеры:
```qsp

DYNEVAL('result = 3+4')
PL DYNEVAL('$result = mid("abcd",2,1)+"qwerty"')
PL DYNEVAL($test + ' + val("<<$test>>")')
проход=DYNEVAL("result = ($args[0] <> 'текст')", 'строка')

```

	*  `Важно:` если код задан с помощью одинарных (' ') или двойных (" ") кавычек, в тексте вычисляются подвыражения.
		*  Пример:
```qsp

$args[0]='qwerty'
$code = '
*pl "<<$args[0]>>"
*pl $args[0]'
$args[0]='12345'

DYNAMIC $code,'asdfg'
! при задании переменной $code будет вычислено подвыражение
! поэтому первой строкой выведется 'qwerty'
! второй строкой выведется 'asdfg'

```

	*  Фигурные скобки - третий вид кавычек используемый специально для написания динамического кода
		*  Поддерживается вложенность скобок
		*  Перед выполнением кода не вычисляются подвыражения.
		*  Примеры:
```qsp

$args[0]='qwerty'
$code = {
  *pl "<<$args[0]>>"
  *pl $args[0]
}

DYNAMIC $code,'asdfg'
! будет выведено две строки 'asdfg'

```

	*  Вполне допустимо использовать dynamic/dyneval внутри dynamic/dyneval, однако это сильно усложняет отладку кода и поиск ошибок.

[Вперёд: Всплывающее меню](help:menu)

[1)](#fnt__1) 
, [2)](#fnt__2) 
10 включая код

