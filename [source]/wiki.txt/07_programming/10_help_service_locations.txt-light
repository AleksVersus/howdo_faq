
[Назад: Переходы внутри локации](help:jump)

==Служебные локации==
[:help_service_locations]

[:sluzhebnye_lokacii]

В QSP существует возможность привязать вызов некоторых локаций к определённым событиям. Например, к выделению предмета в окне предметов, или к переходу на новую локацию с помощью операторов `GOTO`/`XGOTO`.

Чтобы привязать вызов локации к определённому событию, нужно прописать название этой локации в ту или иную системную переменную, предназначенную для связки события с локацией.

```qsp
! назначили обработчик выделения предмета:
$onobjsel = 'ONOBJSEL'
! назначили обработчик перехода на новую локацию:
$onnewloc = 'перерисовка'
! сняли обработчик добавления предмета:
$onobjadd = ''
```

Когда событие происходит, указанная локация вызывается точно так же, как если бы мы вызывали её с помощью оператора [`GOSUB`](help:organizing).

=События в QSP=

В этом разделе перечислены все события в QSP, к которым можно привязать автоматический вызов локаций.

--Загрузка состояния игры--

`$ONGLOAD` —  содержит название локации-обработчика события "загрузка состояния игры" (далее "обработчик загрузки состояния"). Иными словами, в эту переменную записывается название локации, код которой будет выполняться всякий раз после того, как был загружен файл состояния игры ("файл сохранения") с помощью команды `OPENGAME`. Название локации может быть любым.

Назначаем в качестве обработчика загрузки состояния локацию "on_game_load":
```qsp
$ongload="on_game_load"
```

Теперь сразу после выполнения команды `OPENGAME` плеер будет автоматически вызывать локацию "on_game_load".

Чтобы отключить обработчик загрузки состояния, нужно задать переменной `$ONGLOAD` пустое значение:
```qsp
$ongload=""
```

--Сохранение состояния игры--

`$ONGSAVE` - содержит название локации-обработчика события "сохранение состояния игры" (далее "обработчик сохранения состояния"). Иными словами, в эту переменную записывается название локации, код которой будет выполняться всякий раз после того, как было записано состояние игры в новый, или уже существующий, файл состояния игры ("файл сохранения") с помощью команды `SAVEGAME`. Название локации может быть любым.

Назначаем в качестве обработчика сохранения состояния локацию "on_game_save":

```qsp
$ongsave="on_game_save"
```

Теперь сразу после выполнения команды `SAVEGAME` плеер будет автоматически вызывать локацию "on_game_save".

Чтобы отключить обработчик сохранения состояния, нужно задать переменной `$ongsave` пустое значение:
```qsp
$ongsave=""
```

--Добавление предмета в окно предметов--

`$ONOBJADD` —  содержит название локации-обработчика события "добавление предмета в окно предметов" (далее "обработчик добавления предмета"). Иными словами, в эту переменную записывается название локации, код которой выполняется всякий раз после добавления предмета в окно предметов с помощью команды `ADDOBJ`. Название локации может быть любым.

При добавлении предмета этой локации-обработчику передаются два аргумента, значения которых можно получить из `$args[0]` и `$args[1]` соответственно:

	* $ARGS[0] - название добавленного предмета
	* $ARGS[1] - путь к картинке добавленного предмета

Данная локация полезна, к примеру, для ограничения вместительности рюкзака.

Назначаем в качестве обработчика добавления предмета локацию "on_object_add":
```qsp
$onobjadd="on_object_add"
```

Теперь сразу после выполнения команды `ADDOBJ` плеер будет автоматически вызывать локацию "on_object_add".

Чтобы отключить обработчик добавления предмета, нужно задать переменной `$ONOBJADD` пустое значение:
```qsp
$onobjadd=""
```

--Удаление предмета из окна предметов--

`$ONOBJDEL` —  содержит название локации-обработчика события "удаление предмета" (далее "обработчик удаления предмета"). Иными словами, в эту переменную записывается название локации, код которой вполняется всякий раз при удалении предмета с помощью команды `DELOBJ`. Если воспользоваться командой `KILLOBJ`, то это будет аналогично серии команд `DELOBJ`, соответственно и локация-обработчик будет вызвана столько раз, сколько предметов будет удалено с помощью `KILLOBJ`. Название локации может быть любым.

При использовании команды `KILLALL` локация-обработчик удаления предмета не вызывается, поскольку системная переменная `$ONOBJDEL` также уничтожается.

При удалении предмета обработчику удаления предмета передаётся аргумент, значение которого можно получить из `$args[0]`:

	* $ARGS[0] - название удалённого предмета

Назначаем в качестве обработчика удаления предмета локацию "on_object_del":
```qsp
$onobjdel="on_object_del"
```

Теперь сразу после выполнения команды `DELOBJ` плеер будет автоматически вызывать локацию "on_object_del". А сразу после выполнения команды `KILLOBJ` локация "on_object_del" будет вызвана столько раз, сколько предметов удалено этой командой.

Данная локация полезна, к примеру, для проверки возможности удаления предмета:
```qsp
! например есть предмет, который нам пригодится по сюжету
if $args[0]="Важный артефакт":
	! восстанавливаем предмет
	addobj $args[0]
end
```
Чтобы отключить обработчик удаления предмета, нужно задать переменной `$ONOBJDEL` пустое значение:
```qsp
$onobjdel=""
```

--Выделение предмета в окне предметов--

`$ONOBJSEL` —  содержит название локации-обработчика события "выделение предмета" (далее "обработчик выделения предмета"). Иными словами, в этой переменной указывается название локации, код на которой выполняется всякий раз при выделении предмета. Выделение предмета происходит непосредственно при "нажатии" на предмет (щелчок мышью по предмету). Название локации может быть любым.

Назначаем в качестве обработчика выделения предмета локацию "on_object_select":
```qsp
$onobjsel="on_object_select"
```

Теперь всякий раз после щелчка мышью на предмете будет выполняться код локации "on_object_select".

Данная локация полезна, к примеру, для вывода информации о предмете, или для вызова меню предмета. Получить название выбранного предмета можно через функцию `$SELOBJ`.
```qsp
if $selobj = 'чайник':
	p 'Cамый обычный чугунный чайник.'
end
```
При выборе играющим какого-либо предмета, он остаётся выделенным. Повторно выделить уже выделенный предмет нельзя. Снять выделение можно командой `UNSELECT`.

```qsp
if $selobj = 'нож':
  *p 'Этим ножом даже хлеба не нарежешь.'
end
unselect &! или UNSEL
```



	*  Локации:
		*  `$ONNEWLOC` - при переходе на новую локацию
			*  Выполняется перед передачей управления игроку (после выполнения кода всех участвующих в переходах локаций)
			*  Получить название локации, на которую был осуществлён переход, можно с помощью функции "CURLOC"
```qsp

IF $CURLOC = 'дом': кошка = 1

```

	*  Действия:
		*  `$ONACTSEL` - при выборе действия.
			*  Именно при выборе действия, а не при нажатии действия.
			*  Получить название выбранного действия можно через функцию"SELACT".
```qsp

IF INSTR(1, $SELACT, 'Пойти'): PLAY 'sounds\walk.mp3'

```

	*  Время
		*  `$COUNTER` - локация-счетчик вызывается через одинаковые промежутки времени
			*  По умолчанию промежутки 500мс, т.е. 2 раза в секунду
			*  Автоматическое обновление интерфейса срабатывает с той же частотой
			*  Промежутки задаются командой `SETTIMER` [#период] в миллисекундах 
```qsp

SETTIMER 1000/частота_в_герцах

```
```qsp

SETTIMER 1000*период_в_секундах

```

	*  Строка ввода
		*  `$USERCOM` - по нажатию "Enter" в строке ввода
			*  Подробнее по строке ввода см. [Ввод текста игроком](help:inputs)
`Примечание:` При использовании операторов "KILLALL, KILLVAR" очищаются также все системные переменные.

=Несколько обработчиков на одно событие=

Иногда возникает необходимость разгрузить локации-обработчики от большого объёма кода, или разнести логически не связанные фрагменты кода по разным локациям, но привязать код этих локаций к одному событию.

Эта задача решается двумя способами.

	* Назначаем в качестве локации-обработчика какого-либо события одну локацию, а уже из неё с помощью `GOSUB` вызываем необходимые локации, на которых мы разместили фрагменты кода:
		```qsp
		! самая первая локация в игре
		$counter='counter'
		```
		```qsp
		! локация counter
		gosub 'playlist'
		gosub 'rabbit_hole','animation'
		```
	* Используем системную переменную, в которую обычно прописываем название локации-обработчика, как массив, и прописываем локации, на которых мы разместили фрагменты кода, в ячейки этого массива:
		```qsp
		$counter[0]='playlist'
		$counter[1]='rabbit_hole'
		```
		В данном случае плеер будет последовательно одну за другой вызывать локации, прописанные в этом массиве, пока массив не кончится, или пока плеер не встретит пустую ячейку (пустую строку в ячейке).

Обратите внимание на преимущества и недостатки каждого способа.

Первый способ позволяет вызывать сторонние локации из локации-обработчика, передавая на эти локации различные аргументы. Иногда это бывает очень удобно. Однако этот способ не даёт гибкости в управлении фрагментами кода. Вы не можете отключить вызов одной из сторонних локаций.

Второй способ, напротив, делает все перечисленные в массиве локации локациями-обработчиками, и чтобы отключить обработку одной из этих локаций, достаточно удалить соответствующую ячейку. Однако, он не позволяет передавать на локации-обработчики необходимые аргументы.

[Вперёд: Динамический код](help:dynamical)

