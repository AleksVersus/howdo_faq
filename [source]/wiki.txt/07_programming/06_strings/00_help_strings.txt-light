
[Назад: Массивы](help:arrays)

==Строки==
[:help_strings]

[:stroki]

В QSP есть два типа данных: числовой и строковый.

Строковый тип данных отличается тем, что в начале названия строковой переменной или массива должен быть символ '`$`'.

Рекомендуется к названиям всех функций, возвращающих строковые значения, тоже приписывать символ '`$`' для улучшения читаемости кода.

=Константы=
[:konstanty]

Если с числовыми константами в QSP всё просто (просто записывается числом, например, 4593), то со строковыми есть несколько нюансов:

	*  Текстовая константа берётся с двух сторон в кавычки
		*  Кавычки могут быть двух видов: апострофы `' '` и прямые кавычки `" "`
		*  Если нужно в константу включить кавычки того же вида, нужно написать кавычки два раза подряд:
```qsp

*PL 'Byte Soft''s "QSP"'
*PL "Byte Soft's ""QSP"""
!Byte Soft's "QSP"

```

	*  Для текстовых констант сохраняются переносы строк и отступы:
```qsp

'Данный текст
будет расположен на
нескольких строках'

$a='И этот
текст
также'

a=2 & act 'Многострочное
название':gt 'next'

```

		*  При выводе ошибок многострочная (префоматированная) текстовая константа считается за одну строку.
	*  Текстовые константы и значения переменных можно объединять двумя способами:
		*  С помощью оператора конкатенации `&`. Выражение нужно брать в скобки, т.к. оператор `&` также разделяет команды: 
```qsp
 
$res = ('x=' & x & ' y=' & y) &! Результат 'x=5 y=6'
$res = 'x=' & x &!'Результат 'x=', а '5' выведется
в основное окно описания.'

```

		*  С помощью оператора сложения `+`: 
```qsp

$res = 'x=' + x + ' y=' + y &! Результат 'x=5 y=6'

```

			*  Следует соблюдать осторожность, если одно из слагаемых числового типа: 
```qsp

x = 1
$res = '1' + x
!Результат '2' вместо '11'

```

=Сравнение строк=
[:sravnenie_strok]

Строки сравниваются посимвольно, начиная с крайнего левого символа.
```qsp

'ac' = 'ac'
'bc' > 'ac'  &! 'b' > 'a'
'ac' > 'ab'  &! 'c' > 'b'
'b'  > 'ab'  &! 'b' > 'a'
'ab' > 'a'   &! 'b' > ''

```

=Подвыражения=
[:podvyrazhenija]

В строковые константы, в базовые описания локаций и названия базовых действий существует возможность вставлять значения выражений. Такие "подвыражения" должны находиться между двойных угловых скобок: "`<<`" и "`>>`", до и после которых может идти любой текст, включая подобные "подвыражения".

```qsp

pl 'i='+str(i)
!эквивалентно
pl 'i=<<i>>'

число_гоблинов=5
'Тебя окружили <<число_гоблинов>> гоблинов!'

pl 'Вас зовут <<$PlayerName>>, вы находитесь в <<$curloc>>.'

!Вложенные подвыражения:
pl val('<<val("<<i>>")>><<j>>')
pl val('<<str(val("<<i>>"))>>')
!'При использовании вложенных подвыражений
необходимо использовать вложенные строковые константы'

```

Если нужно вывести последовательность "`<<`" на экран, можно использовать два способа:

	*  Разбить '`<<`' на '`<`'+'`<`': 
```qsp

$text = '<'+'<var>>'
'string <'+'<var>>'

```

	*  `DISABLESUBEX` - системная переменная, "выключающая" подвыражения при неравенстве 0:
```qsp

DISABLESUBEX=1
$text = '<<var>>'
'string <<var>>'
DISABLESUBEX=0

```

=Функции=
[:funkcii]

	*  `LEN(`[$стр]`)` - возвращает длину строки [$стр].
	*  `MID(`[$стр]`,`[#начало]`,`[#длина]`)` - вырезает из строки [$стр] строку, которая начинается с символа номер [#начало] и имеет длину [#длина]. Индексация символов в строке ведётся с 1.
		*  Параметр [#длина] может отсутствовать, при этом вырезается вся строка, начиная с символа [#начало]. 
		*  Примеры:
```qsp

$MID('abcd', 1, 2) &! 'ab'
$MID('abcd', 2, 3) &! 'bcd'
$MID('abcd', 2)    &! 'bcd'

```

	*  `UCASE(`[$стр]`)` - возвращает строку больших букв, полученную изменением регистра букв исходной строки [$стр]. 
```qsp
$UCASE('TexT#') &! 'TEXT#'
```

	*  `LCASE(`[$стр]`)` - возвращает строку маленьких букв, полученную изменением регистра букв исходной строки [$стр]. 
```qsp
$LCASE('TExT#') &! 'text#'
```

	*  `TRIM(`[$стр]`)` - удаляет прилегающие пробелы и символы табуляции из [$стр] и возвращает полученную строку. 
```qsp
$TRIM(' TRIM TEST ') &! 'TRIM TEST'
```

	*  `REPLACE(`[$стр]`,`[$поиск]`,`[$замена]`)` - заменяет в строке [$стр] все вхождения строки [$поиск] строкой [$замена].
		*  Параметр [$замена] может отсутствовать и принимается равным пустой строке.
		*  Примеры:
```qsp

$REPLACE('test', '12', '4') &! 'test'
$REPLACE('test', 'e', 's')  &! 'tsst'
$REPLACE('test', 't', '34') &! '34es34'
$REPLACE('test', 't')       &! 'es'

```

	*  `INSTR(`[#начало]`,`[$строка]`,`[$поиск]`)` - возвращает номер позиции символа, с которого начинается вхождение строки [$поиск] в строку [$строка] (или 0, если такой строки нет). Поиск начинается с символа номер [#начало].
		*  Параметр [#начало] может отсутствовать, при этом он принимается равным `1`.
		*  `Важно:` в более новых версиях (Quest Navigator) необязательный параметр [#начало] переставлен последним[1)](#fn__1).
		*  Примеры:
```qsp

INSTR(1,'ABCDefgh','BC') &! 2
INSTR(1,'ABCDefgh','Be') &! 0
INSTR('abcdef','abc')    &! 1

```

	*  `ISNUM(`[$строка]`)` - функция проверяет, является ли строка [$строка] числом. Функция возвращает 0 (ложь) или -1 (истина). 
```qsp

ISNUM(' 9999 ') &! -1
ISNUM(' -888')  &! -1
ISNUM('777a6')  &! 0
ISNUM('')       &! -1, т.к. пустая строка считается нулём

```

	*  `VAL(`[$стр]`)` - переводит строку цифр [$стр] в соответствующее число. При ошибке возвращается 0.
```qsp
яблоки = VAL($яблоки)
```

	*  `STR(`[#число]`)` - переводит число (числовое выражение) в соответствующую строку. 
```qsp
PL STR(56)
```

--Функции использующие регулярные выражения--
[:funkcii_ispolzujuschie_reguljarnye_vyrazhenija]

	*  `STRCOMP(`[$строка]`,`[$шаблон]`)` - проводит сравнение строки [$строка] на соответствие регулярному выражению [$шаблон]. Возвращает -1, если строка соответствует шаблону, иначе 0. Сравни с функцией "STRFIND".
	*  `STRFIND(`[$строка]`,`[$шаблон]`,`[#номер]`)` - возвращает подстроку в строке [$строка], соответствующую группе с номером [#номер] регулярного выражения [$шаблон].
		*  Если подстрока с указанным номером отсутствует, то возвращается пустая строка.
		*  Нумерация групп подстрок начинается с 1.
		*  Если параметр [#номер] отсутствует или равен 0, то возвращаются подстрока, соответсвующая всему регулярному выражению.
		*  Примеры:
```qsp

STRFIND(' идти к пещере', '^(\S+)\s(\S+)\s(\S+)$', 0) &! ''
STRFIND('идти к пещере', '^(\S+)\s(\S+)\s(\S+)$', 1)  &! 'идти'
STRFIND('идти к пещере', '^(\S+)\s(\S+)\s(\S+)$', 2)  &! 'к'
STRFIND('идти к пещере', '^(\S+)\s(\S+)\s(\S+)$', 3)  &! 'пещере'
STRFIND('идти к дому', 'к\s(\S+)', 0) &! 'к дому' 
STRFIND('идти к дому', 'к\s(\S+)')    &! 'к дому'
STRFIND('идти к дому', 'к\s(\S+)', 1) &! 'дому'
STRFIND('идти к своему дому', 'к\s(\S+)', 1) &! 'своему'

```

	*  `STRPOS(`[$строка]`,`[$шаблон]`,`[#номер]`)` - возвращает позицию символа, с которого начинается вхождение подстроки в строку [$строка], соответствующей группе с номером [#номер] регулярного выражения [$шаблон].
		*  Если подстрока с указанным номером отсутствует, то возвращается 0.
		*  Нумерация групп подстрок начинается с 1.
		*  Если параметр [#номер] отсутствует или равен 0, то возвращается позиция символа, с которого начинается вхождение подстроки, соответствующей всему регулярному выражению.
		*  Примеры:
```qsp

STRPOS(' идти к пещере', '^(\S+)\s(\S+)\s(\S+)$', 0) &! 0
STRPOS('идти к пещере', '^(\S+)\s(\S+)\s(\S+)$', 1)  &! 1
STRPOS('идти к пещере', '^(\S+)\s(\S+)\s(\S+)$', 2)  &! 6
STRPOS('идти к пещере', '^(\S+)\s(\S+)\s(\S+)$', 3)  &! 8
STRPOS('идти к пещере', '^(\S+)\s(\S+)(\s(\S+))?$', 4) &! 8
STRPOS('идти к дому', 'к\s(\S+)', 0) &! 6
STRPOS('идти к дому', 'к\s(\S+)')    &! 6
STRPOS('идти к дому', 'к\s(\S+)', 1) &! 8
STRPOS('идти к своему дому', 'к\s(\S+)', 1) &! 8

```

[Вперёд: Регулярные выражения](../help/regexp.html)

[1)](#fnt__1)
`INSTR(`[$строка]`,`[$поиск]`,`[#начало]`)`

