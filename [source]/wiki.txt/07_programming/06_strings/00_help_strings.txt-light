
[Назад: Массивы](help:arrays)

==Строки==
[:help_strings]

[:stroki]

В `QSP` есть два типа данных: числовой и строковый. В данном разделе мы рассмотрим строковый тип данных и способы работы с ним.

При присвоении строкового значения переменной, перед именем такой переменной обязательно нужно ставить символ '`$`'. То же самое при получении строкового значения из переменной.

```qsp
$text="Зелёное яблоко" &! помещаем строковое значение в переменную
*pl $text &! выводим на экран значение строковой переменной
```

Так же рекомендуется к названиям всех функций, возвращающих строковые значения, приписывать символ '`$`' для улучшения читаемости кода.

```qsp
$max('Петя','Вася','Лёша','Дима')
$text = $str(453+111)
$name = $input('Введите имя:')
```

=Константы=
[:konstanty]

Под константой следует понимать одно конкретное значение. Например, число 1441 — это числовая константа, а строка "Зелёные яблоки" — это строковая константа.

Если с числовыми константами в QSP всё просто (записываем число, используя набор цифр; например, 4953), то со строковыми есть несколько нюансов:

	*  Строковая константа берётся с двух сторон в кавычки (обрамляется кавычками).
		*  Кавычки могут быть двух видов: апострофы `' '` и прямые кавычки `" "`
		*  Если нужно в константу включить кавычки того же вида, нужно написать кавычки два раза подряд:
		```qsp
		*PL 'Byte Soft''s "QSP"'
		*PL "Byte Soft's ""QSP"""
		!Byte Soft's "QSP"
		```
	*  В строковых константах сохраняются переносы строк и отступы:
	```qsp
	'Данный текст
	будет расположен на
	нескольких строках'

	$a='И этот
	    текст    
	также'

	a=2 & act 'Многострочное
	название':gt 'next'
	```
	*  Если ошибка допущена внутри строковой константы, то вся многострочная константа будет считаться одной строкой при выводе ошибки.
	*  Текстовые константы и значения переменных можно объединять двумя способами:
		*  С помощью оператора конкатенации `&`. Выражение нужно брать в скобки, т.к. оператор `&` также разделяет команды: 
		```qsp
		$res = ('x=' & x & ' y=' & y) &! В переменную $res запишется 'x=5 y=6'
		$res = 'x=' & x &! В переменную $res запишется  'x=', а '5' выведется в основное окно описания.
		```
		*  С помощью оператора сложения `+`: 
		```qsp
		$res = 'x=' + x + ' y=' + y &! Результат 'x=5 y=6'
		```
			*  Следует соблюдать осторожность, если одно из слагаемых числового типа: 
			```qsp
			x = 1
			$res = '1' + x
			!Результат '2' вместо '11'
			```

=Сравнение строк=
[:sravnenie_strok]

Точно так же, как и числовые значения, мы можем сравнивать строковые значения. При этом операции сравнения будут возвращать 1, если равенство верно, и 0, если равенство неверно.

```qsp
if 'abc'='abc': 'Условие выполнено'
*pl ('abc'='abc') & ! увидим на экране единицу
*pl ('abc'>'ab') & ! увидим на экране единицу
*pl ('abc'<'abc') & ! увидим на экране ноль
```

Строки сравниваются посимвольно, начиная с крайнего левого символа.

```qsp
! это не валидный код qsp
! а табличка сравнения строковых констант
'ac' = 'ac'
'bc' > 'ac'  &! 'b' > 'a'
'ac' > 'ab'  &! 'c' > 'b'
'b'  > 'ab'  &! 'b' > 'a'
'ab' > 'a'   &! 'b' > ''
```

=Подвыражения=
[:podvyrazhenija]

`QSP` позволяет вставлять значения различных выражений в строковые константы, а так же в базовые описания локаций и названия базовых действий. Для этого используются специальные конструкции из двойных угловых скобок:  "`<<`" и "`>>`". Выражения, помещённые в такие двойные угловые скобки, называются `подвыражениями`, или `вложенными выражениями`.

Примеры:

```qsp
число_гоблинов=5
'Тебя окружили <<число_гоблинов>> гоблинов!'
! на экране будет строка:
! `Тебя окружили 5 гоблинов!`
```

```qsp
pl 'Вас зовут <<$playerName>>, вы находитесь в <<$curloc>>.'
```

Когда плеер встречает подобное подвыражение, он это подвыражение `раскрывает`, то есть плеер вычисляет значение выражения, помещённого в двойные угловые скобки, а затем вместо угловых скобок с этим выражением подставляет полученное значение.

Другие примеры:

```qsp
pl 'i='+$str(i)
!эквивалентно
pl 'i=<<i>>'
```

Подвыражения можно вкладывать друг в друга. Здесь очень важно соблюдать чередование кавычек, если вы это делаете:

```qsp
!Вложенные подвыражения:
pl val('<<val("<<i>>")>><<j>>')
pl val('<<$str(val("<<i>>"))>>')
!'При использовании вложенных подвыражений
необходимо использовать вложенные строковые константы'
```

Если нужно последовательность "`<<`" вывести на экран, или поместить в переменную, можно воспользоваться одним из этих способов:

	*  Разбить '`<<`' на '`<`'+'`<`': 
	```qsp
	$text = '<'+'<var>>'
	'string <'+'<var>>'
	```
	* Использовать фигурные скобки:
	```qsp
	$text={<<var>>}
	*pl {string <<var>>}
	```

Фигурные скобки — это ещё один способ создавать строковые константы. При их использовании создаются точно такие же строковые константы, как и в случае с обычными кавычками, однако в таких константах не раскрываются подвыражения. К тому же текст, размещённый в фигурных скобках не подсвечивается непосредственно как текст различными редакторами (например, Quest Generator), а подсвечивается как обычный код. Поэтому фигурные скобки обычно используют для создания [динамического кода](help:dynamical).

=Функции=
[:funkcii]

	*  `LEN(`[$стр]`)` - возвращает длину строки [$стр].
	```qsp
	*pl len('Зелёные яблоки') &! на экране будет число 14
	```
	*  `$MID(`[$стр]`,`[#начало]`,`[#длина]`)` - вырезает из строки [$стр] строку, которая начинается с символа номер [#начало] и имеет длину [#длина]. Нумерация символов в строке ведётся с 1.
		* Параметр [#длина] может отсутствовать, при этом вырезается вся строка, начиная с символа [#начало].
		* Если [#начало] превышает длину строки, функция возвращает пустую строку.
		*  Примеры:
		```qsp
		$MID('abcd', 1, 2) &! 'ab'
		$MID('abcd', 2, 3) &! 'bcd'
		$MID('abcd', 2)    &! 'bcd'
		$mid('abcd',5) &! '' (пустая строка)
		```
	*  `$UCASE(`[$стр]`)` - возвращает строку больших букв, полученную изменением регистра букв исходной строки [$стр]. 
	```qsp
	$UCASE('TexT#') &! 'TEXT#'
	```
	*  `$LCASE(`[$стр]`)` - возвращает строку маленьких букв, полученную изменением регистра букв исходной строки [$стр]. 
	```qsp
	$LCASE('TExT#') &! 'text#'
	```
	*  `$TRIM(`[$стр]`)` - удаляет прилегающие пробелы и символы табуляции из [$стр] и возвращает полученную строку. 
	```qsp
	$TRIM(' TRIM TEST ') &! 'TRIM TEST'
	```
	*  `$REPLACE(`[$стр]`,`[$поиск]`,`[$замена]`)` - заменяет в строке [$стр] все вхождения строки [$поиск] строкой [$замена].
		*  Параметр [$замена] может отсутствовать и принимается равным пустой строке.
		*  Примеры:
		```qsp
		$REPLACE('test', '12', '4') &! 'test'
		$REPLACE('test', 'e', 's')  &! 'tsst'
		$REPLACE('test', 't', '34') &! '34es34'
		$REPLACE('test', 't')       &! 'es'
		```
	*  `INSTR(`[$строка]`,`[$поиск]`,`[#начало]`)` - возвращает номер позиции символа, с которого начинается вхождение строки [$поиск] в строку [$строка] (или 0, если вхождения нет). Поиск начинается с символа номер [#начало].
		*  Параметр [#начало] может отсутствовать, при этом он принимается равным `1`.
		*  Примеры:
		```qsp
		INSTR('ABCDefgh','BC',1) &! 2
		INSTR('ABCDefgh','Be',1) &! 0
		INSTR('abcdef','abc')    &! 1
		```
	*  `ISNUM(`[$строка]`)` - функция проверяет, является ли строка [$строка] числом. Функция возвращает 0 (ложь) или 1 (истина). 
	```qsp
	ISNUM(' 9999 ') &! 1
	ISNUM(' -888')  &! 1
	ISNUM('777a6')  &! 0
	ISNUM('')       &! 0, т.к. пустая строка не содержит числа
	```
	*  `VAL(`[$стр]`)` - переводит строку цифр [$стр] в соответствующее число. При ошибке возвращает 0.
	```qsp
	яблоки = VAL($яблоки)
	val('123') & ! увидим 123
	val('') & ! увидим 0
	val('sand') & ! увидим 0
	```
	*  `$STR(`[#число]`)` - переводит число (числовое выражение) в соответствующую строку. 
	```qsp
	PL $STR(56)
	```

[Вперёд: Регулярные выражения](help:regexp)

