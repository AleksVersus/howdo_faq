взаимодействие с файлами
----------------------------------------------------------------------
=Chaos Legion=
http://qsp.su/index.php?option=com_agora&task=topic&id=40&p=156&prc=25&Itemid=57#p22957
Извиняюсь если было, но 400 страниц листать это слишком. 
Рандомное вставление изображений из папки. Изображения 1 - n.jpg 
при точном количестве файлов сабж не вызывают вопроса, а вот как сделать, чтобы при добавлении новых файлов не менять код? 
в голову лезет что то типа 
:ImgRoll 
img = rand (1,10000) 
вставить img.jpg 
если файла нет то: 
jump 'ImgRoll' 

как такое организовать? 
Комментарии знатоков....

=Aleks Versus=
классический плеер не умеет определять наличие файла в папке.

=Chaos Legion=
я в qsp новичек, может есть возможность зафигачить все в функцию и делать проверку null через возврат аргумента или еще чего там есть в программировании... 
Вариант с 
rand 1,3 
if 1 img 1 
if 2 img 2 
так же эффективен, как и не элегантен, громоздок не гибок 

стоп, а в "<img src="img/loc/3.jpg">" переменную же можно вставить ?

=Svartberg=
Для начала точно определись с тем, сколько имгов у тебя будет в папке. Сомневаюсь, что более 1000, поэтому можешь использовать цикл и делать проверку как в прошлом примере. 
И да, можно запихать переменную: 
"<img src="/img/loc/<<rand.value>>.jpg">" 
(Но, на самом деле, только мороки добавишь и возможных багов. Крепко подумай для начала, надо ли?) 
Лучше определись с кол-вом файлов, пронумеруй их и задай рандом в их диапазоне.

=Chaos Legion=
"Лучше определись с кол-вом файлов" - это слишком просто big_smile я хочу упороться :DDDD 

p.s. поразмыслил. Если qsp, как например и PHP сначала,основываясь на коде генерит страницу HTML, а потом браузерная часть ее обрабатывает и выводит, то проверка невозможна. Значит только Aeroqsp через java смоожет. Если это так вопрос исчерпан.

=Aleks Versus=
ты имеешь ввиду javascript? Теоретически в QuestNavigator можно, конечно, проверять предзагрузкой наличие картинки, onerror там или как ещё. Но можешь, например, воспользоваться таким способом, который можно использовать в твоём алгоритме: 
Создаёшь функцию типа: 

Код:
!#prv_img 
if instr($desc('prv_img'),$args[0])!0: 
   $result='true' 
else 
   $result='false' 
end
Поскольку эта функция будет создана отдельной локацией, к этой локации можно применять команды для локаций ($desc в нашем случае). При добавлении файла в папку, его адрес добавляешь и в базовое описание локации (в которой написана эта функция). 

Теперь в твоём алгоритме можно использовать эту функцию: 

Код:
:ImgRoll 
img = rand (1,10000) 
if $func('prv_img','<<img>>.jpg')='true': 
   вставляем изображение 
else 
   jump 'ImgRoll' 
end

=evp=
<img src = "img/loc/1.jpg" onerror = "this.style.display = 'none'">
В Навигаторе, конечно.

=Aleks Versus=
Тут мы просто не выводим картинку на экран. Но, как я понял, задача чуть сложнее: проверить наличие картинки и дать понять QSP-коду, что картинки нет.

=evp=
Aleks Versus, если я не ошибаюсь, то взаимодействие QSP и JS это дорога с односторонним движением. Можно передать параметры из QSP в JS, но наоборот нельзя. 

Например, можно написать функцию типа

Код:
function GetFolderList(folderaddress)
Но передать результат ее работы в QSP не вижу возможности. Поэтому, начав в QSP логику работы с изображениями, а продолжив в JS, вернуться в QSP не получится. Придется продолжать в JS. Но это не выход, так как в этой ситуации мы приходим к выводу, что всю игру проще будет написать на JS и QSP становится лишним.
=evp=
А что касается оригинального вопроса, то вывод случайной картинки из определенной папки, вполне решается средствами JS. Вкратце, алгоритм следующий:

получаем список файлов в папке;
 Спойлер Show Spoiler Hide Spoiler
 
Код:
//функция написана не для этого случая и не мной, привожу ее как пример принципиальной возможности 
function GetFolderList(folderaddress) 
{ 
   var fso, f, fc, s; 
   fso = new ActiveXObject("Scripting.FileSystemObject"); 
   f = fso.GetFolder(folderaddress);          
   fc = new Enumerator(f.files);          
   s = ""; 
   for (; !fc.atEnd(); fc.moveNext()) 
   { 
         TestFile(fc.item()); 
         s += fc.item();            
          s += "\n";   } 
   return(s); 
}
выбираем случайный и отображаем его, "не выходя" из JS.
=evp=
Хотя, если еще подумать... 
Задачка оказалась настолько интересной, что пришла идея использовать вот такой "хак":

Код:
*clr 
$folderaddress = 'img/pic' 
*nl"<div style='display:none'>" 
    *p EXEC('JS:GetFolderList(<<$folderaddress>>);') 
*p</div> 
$imglist = $MAINTXT 
*clr 
*nl $func('randimg',$imglist) 
Функцию randimg по распарсиванию списка и выбору случайного файла предоставляю честь написать тебе smile Ты на этом собаку съел.

=Aleks Versus=
вот именно! big_smile  Мы со Storm около месяца назад (может больше) обсуждали такой подход передачи данных из JS в QSP. Но реализовать ещё не пробовали. Выводим данные, полученные через JS на экран, сохраняем в переменную, очищаем экран, и парсим нужные данные. Костыль, конечно, но что поделать. 
Вот только я не уверен, что браузерный JS даст возможность получить список файлов в папке.

=evp=
К сожалению, все еще хуже. Мне не удалось вывести на экран результаты из JS. 

document.getElementById('myid').innerHTML = 'Новый текст'; 
не справился с задачей. Ничего не заменяет, причина неизвестна, но это и неважно, ниже объясню почему. 

document.write(Hello, world); 
работает, но, видимо, он срабатывает уже после того как html-страница сформирована, следовательно все содержимое заменяется на аргумент метода. Это нам дает полное удаление всех окон (основного и дополнительного описаний и действий), форматирования, короче, девственно-чистый html-документ smile 

Но я пришел к выводу, что абсолютно неважно, что мы напишем в окне при помощи JS - это все останется только в сформированном html-документе и не имеет отношения к тому, что "хотел" написать QSP, а, следовательно, к тому, что возвращает $maintxt. Другими словами, мы можем что угодно писать в html, но QSP об этом знать ничего не будет ибо $maintxt возвращает не то, что на самом деле написано в html, а лишь мнение QSP о том, что должно быть там написано. 

Что касается изначально поставленной задачи о картинках, то JS способен ее решить, но не в Навигаторе. Для доступа к файловой системе нужно использовать ActiveX, доступный в браузерах Microsoft, а мы имеем, к сожалению, WebKit-браузер. 

Как ее решение могу предложить следующий алгоритм, который будет работать как в классике, так и в Навигаторе. 
Некий исполняемый файл (это может быть даже bat-файл) 

составляет список файлов в указанной папке/папках;

сохраняет результаты своей работы в текстовый документ, используя синтаксис txt2gam для формирования нужных переменных или массивов;

конвертирует этот файл в .qsp, используя txt2gam.exe;

запускает игру.


В самой игре используется функция ADDQST/ADDLIB/INCLIB для присоединения получившегося модуля.

=Aleks Versus=
прискорбно. Хотя следовало ожидать. Скрипт, засунутый в описание, при попытке вытащить его, конечно будет не изменённым скриптом. Эффект, производимый им, полностью лежит на плечах браузера, который "исходный" код страницы не может менять. Даже по-моему Nex что-то такое пару раз говорил.