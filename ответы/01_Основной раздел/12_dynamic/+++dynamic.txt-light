dynamic
------------------------------------------------------------
=Storm=
http://qsp.su/index.php?option=com_agora&task=topic&id=40&p=113&prc=25&Itemid=57#p19941
Возникла такая ситуации: мне нужно к названию массива, допустим, char прибавить число 1, 2 и так далее чтобы получить название нового массива, допустим char1. Затем в этот новый массив копировать данные из какого-то другого массива в игре. Возможно ли это реализовать в QSP? Как вчера не пытался, не смог придумать как это записать в операторах.

=Oliver=
!номер массива 
char = 1 
!и остальное 
char_money = 200 
$char = 'Бомж' 
Дальше пишешь char = 2 и все что тебе нужно.

=snail=
copyarr 'char1', 'char'

Про массиВы смотри в документации статью Массивы.

прибавить число 1, 2 и так далее

Тебе это нужно в цикле делать?

=Aleks Versus=
Можно динамически формировать названия массивов. Копируем содержимое массива char в десять автоматически генерируемых массивов:

i=1
:for
if i<11:
	copyarr 'char<<i>>','char'
	i+=1
	jump 'for'
end
-------------------------------------------------------------------------------------
=Hungry=
http://qsp.su/index.php?option=com_agora&task=topic&id=40&p=125&prc=25&Itemid=57#p20811
Вопрос такой: можно ли сделать, чтобы игра создавала переменную с рандомным НАЗВАНИЕМ?

=Nex=
DYNAMIC
------------------------------------------------------------------------------------------
=Chaos Legion=
http://qsp.su/index.php?option=com_agora&task=topic&id=40&p=160&prc=25&Itemid=57#p23212
так чето я немного конкретно затупил: 
есть лока changestat которая вызывается по gs и ей передается имя переменной и число, например: 
gs 'changestat', 'hp', -100 
или 
gs 'changestat', 'armor', 10 

сама лока должна к этой переменной добавлять число, но я не могу понять, как там оперировать именно переменной, а не args[0] 

p.s. if не предлагать, очень уныло, да и переменных туева хуча. 
тоесть 
If $args[0] = 'hp': 
     hp += args[1] 
end 
If $args[0] = 'armor' 
     armor += args[1] 
end 
работает, но не то что надо

=Storm=
Chaos Legion, я так понимаю тебе надо написать функцию для общего случая, чтобы она работала без нагромождений условий. Я бы сделал используя оператор DYNAMIC. 
Локация, на которой лежит твоя функция: 

Код:

gs 'changestat', 'hp', -100 
Сама локация 'changestat': 

Код:

DYNAMIC '<<$ARGS[0]>>+=<<ARGS[1]>>' 
Здесь: 
$ARGS[0] - название переменной, которую нужно изменить 
ARGS[1] - на сколько нужно изменить переменную

=Chaos Legion=
Спасибо. Не знаю как, но работает. 
Даже ограничения работают: 

DYNAMIC 'if <<$ARGS[0]>> < 0 : <<$ARGS[0]>> = 0' 
DYNAMIC 'if <<$ARGS[0]>> > 10000: <<$ARGS[0]>> = 10000'

=Storm=
DYNAMIC выполняет код, записанный в виде строки текста. Но прежде чем выполнить код, записанный как текст, он формирует строку, если в ней есть подвыражения(то, что записано в таких скобочках <<какой-то_аргумент>>). 
То есть оператор DYNAMIC в твоем случае выполняет не строку 

Код:

'<<$ARGS[0]>>+=<<ARGS[1]>>' 
а строку 

Код:

hp+=-100 
Поэтому оно и работает.
---------------------------------------------------------------------------------------
=Hinkmar=
http://qsp.su/index.php?option=com_agora&task=topic&id=40&p=201&prc=25&Itemid=57#p25505
Доброго всем вечера. 
Возник вопрос: можно ли проверить соответствие истине выражения, записанного в текстовую переменную? Вот, например, присвоили мы: 

Код:
$A='B=10'
Можно ли теперь что-нибудь сделать с переменной $A, чтобы как-то узнать истинно это выражение или ложно? Подружить if с dynamic для решения этой задачи у меня не получилось. Вопреки моим надеждам, такая запись не работает: 

Код:
if dynamic '$A': 'true'

=Aleks Versus=
ты неправильно подходишь к dynamic. dynamic не даёт результата, он просто выполняет код. В твоём случае можно сыграть так: 

Код:
$A='B=10' 
dynamic "if <<$A>>: 'true'" 
! фактически dynamic выполнит строку кода: 
! if B=10: 'true'