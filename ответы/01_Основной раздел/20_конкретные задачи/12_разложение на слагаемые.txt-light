=20.12. Как решить задачу по поиску случайного набора слагаемых?=
[:faq_20_12]
В: Как решить задачу по поиску случайного набора слагаемых?

	Например, есть набор чисел 2,3,5 и 9, и нужно случайным образом выбрать из них несколько чисел (можно одинаковых), которые в сумме составляют 9. Как это реализовать?

О:
	Для начала разберём алгоритм для этого конкретного случая, а затем попытаемся написать более универсальную процедуру.
```qsp
		! заполняем массив числами (они определены) - исходный массив
		mass[0]=2
		mass[1]=3
		mass[2]=5
		mass[3]=9
		! задаём "сумму" выброшенных чисел = 9
		summ = 9

		! далее начинается цикл. Метка:
		:for
		! выкидываем число
		! получаем индекс
		index = rand(0,arrsize('mass')-1)
		! фиксируем число
		number=mass[index]
		! проверяем, возможно ли вычитание
		if summ - number = 0:
			! если при вычитании числа из summ получается 0, значит мы нашли последнее число
			! записываем его
			search[]=number
		elseif summ - number < min('mass'):
			! если разность summ и числа - меньше минимального значения в массиве, значит
			! число, которое мы вытянули, нам не подходит
			! и не подойдёт, его можно убрать из исходного массива
			killvar 'mass',index
			! записывать его не нужно, просто возвращаемся и повторяем цикл
			jump 'for'
		else
			! во всех остальных случаях число нам подходит:
			! запоминаем его в конечный массив
			search[]=number
			! уменьшаем summ на это число
			summ -= number
			! повторяем цикл
			jump 'for'
		end
```
	Как видим, алгоритм генерации случайного набора слагаемых довольно прост. Однако он предполагает, что нам изначально известны слагаемые, на которые может быть разложена исходная сумма.

	Можно написать универсальную процедуру для подобных случаев (назовём её "summ.break"):
```qsp
		!#summ.breake
		args[0] = args[0] & ! Сумма, для которой мы получаем набор слагаемых
		$args[1] = $args[1]+',' & ! набор слагаемых через запятую
		! предварительно вытаскиваем в массив mass[] наши слагаемые
		:price
		if len($args[1])>0:
			! запоминаем число
			mass[]=val($mid($args[1],1,instr($args[1],",")-1))
			! удаляем его из строки
			if instr($args[1],",")<>len($args[1]):
				$args[1]=$mid($args[1],instr($args[1],",")+1)
			else
				$args[1]=''
			end
			jump 'price'
		end

		! Теперь выполняем тот же алгоритм, что мы уже писали,
		! только исключая лишние глобальные переменные  (используем args)

		! начинается цикл. Метка:
		:for
		! получаем число (слагаемое) из массива
		! получаем индекс
		args['index'] = rand(0,arrsize('mass')-1)
		! фиксируем число
		args['number']=mass[args['index']]

		! проверяем, возможно ли вычитание
		if args[0] - args['number'] = 0:
			! если при вычитании числа из args[0] получается 0, значит мы нашли последнее число
			! записываем его
			search[]=args['number']
		elseif args[0] - args['number'] < min('mass'):
			! если разность args[0] и числа - меньше минимального значения в массиве, значит
			! число, которое мы вытянули, нам не подходит
			! и не подойдёт, его можно убрать из исходного массива
			killvar 'mass',args['index']
			! записывать его не нужно, просто возвращаемся и повторяем цикл
			jump 'for'
		elseif arrsize('mass')<1:
			! защита от дурака. Если размер массива mass упал до нуля, значит мы перебрали все
			! возможные варианты и значит изначальное условие задано неверно или
			! решение, которое начал подбирать алгоритм изначально неверно подбиралось
			! *pl 'неверное решение'
			! $result = 'false'
			jump 'endandexit'
		else
			! во всех остальных случаях число нам подходит:
			! запоминаем его в конечный массив
			search[]=args['number']
			! уменьшаем args[0] на это число
			args[0] -= args['number']
			! повторяем цикл
			jump 'for'
		end
		! результат прописывается в массив search
		! массив mass удаляем, он был временным
		:endandexit
		killvar 'mass'
		exit
```
	Вариант вызова для исходной задачи:
```qsp
		gosub 'summ.break',9,'2,3,5,9'
```
	Данный алгоритм не включает в себя защиту от некоторых ошибок. Две очевидные:

		* Вы не знаете изначально можно ли получить для данного числа хоть один набор слагаемых из тех, что даны.
		* Перечень слагаемых включает числа, из которых можно получить набор слагаемых, но не во всех случаях.

	Обе эти ошибки не должны приводить к зацикливанию, но их всё равно стоит избегать.

http://qsp.su/index.php?option=com_agora&task=topic&id=40&p=178&prc=25&Itemid=57#p24072

См. так же: тянем карту из колоды, сортировка данных.