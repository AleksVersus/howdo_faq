разложение слагаемых
---------------------------------------------------------------------------
=Genryzz=
http://qsp.su/index.php?option=com_agora&task=topic&id=40&p=178&prc=25&Itemid=57#p24072
Назрел ещё вопрос. Нужно получить определенную сумму из случайных чисел. Случайные числа определенны, но их количество зависит от суммы. После того как числа и их кол-во определенны они выводятся. 

Пример. Сумма равна 9. Случайные числа выбираются из 2,3,5 и 9. Итого у нас группы 2,2,5 ; 2,2,2,3 ; 3,3,3 ; и 9. 

Как создать такую функцию?

=Aleks Versus=
Это своего рода частный случай разложения на слагаемые. Примитивный вариант: 

 Спойлер Show Spoiler Hide Spoiler
 
Код:
! заполняем массив числами (они определены) - исходный массив 
mass[0]=2 
mass[1]=3 
mass[2]=5 
mass[3]=9 
! задаём "сумму" выброшенных чисел = 9 
summ = 9 
! далее начинается цикл. Метка: 
:for 
! выкидываем число 
    ! получаем индекс 
    index = rand(0,arrsize('mass')-1) 
    ! фиксируем число 
    number=mass[index] 
    
! проверяем, возможно ли вычитание 
if summ - number = 0: 
! если при вычитании числа из summ получается 0, значит мы нашли последнее число 
    ! записываем его 
    search[]=number 
elseif summ - number < min('mass'): 
! если разность summ и числа - меньше минимального значения в массиве, значит 
    ! число, которое мы вытянули, нам не подходит 
    ! и не подойдёт, его можно убрать из исходного массива 
    killvar 'mass',index 
    ! записывать его не нужно, просто возвращаемся и повторяем цикл 
    jump 'for' 
elseif summ - (number + min('mass')) < 0: 
! если разность между summ и суммой выпавшего и минимального чисел в массиве 
! меньше нуля, это число так же нам не подходит и не подойдёт 
    killvar 'mass',index 
    jump 'for' 
    ! можно объединить с предыдущим условием через оператор OR 
else 
! во всех остальных случаях число нам подходит: 
    ! запоминаем его в конечный массив 
    search[]=number 
    ! уменьшаем summ на это число 
    summ -= number 
    ! повторяем цикл 
    jump 'for' 
end 
Для проверки достаточно 
Код:
i=0 
:print 
if i<arrsize('search'): 
    *pl 'search[<<i>>] = <<search[i]>>' 
    i+=1 
    jump 'print' 
end
Это, повторюсь, примитивный вариант, где не учитываются многие моменты, хотя в данном конкретном случае он работает, и будет работать в ряде других случаев с другими суммами, которые разлагаются на данные слагаемые. 

P.S.: Хотя я вот сейчас подумал, может быть неправильно понимаю задачу? 
1. Случайным образом выкидывается сумма = 9 
2. Случайным образом выкидываются числа в пределах суммы? Т.е. 2, 3, 5, 9 - выпали случайно? 
3. Потом функция находит группу чисел из этих случайно выпавших, которые дадут в итоге искомую сумму? 
Задача так стоит? Или всё таки числа определены заранее.

=Genryzz=
Если поподробнее то речь идет о том что есть группа монстров. Каждый монстр имеет цену в определенное количество очков. Цель - при каждом столкновении с определенной группой встречать разных монстров в разном количестве. 

Пример 

Заранее заданные параметры 
Группа1 = 10(сумма всех очков монстров в группе) 
Группа2 = 16 

Монстры 
Имп_цена = 2 
Демон_цена = 4 
Дьявол_цена = 8 
/Заранее заданные параметры 

Один из возможных результатов. 
Итого Группа1 состоит из монстр[1] = Имп ; монстр[2] = Имп ; монстр[3] = Имп ; монстр[4] = Демон 
Итого Группа2 состоит из монстр[1] = Дьявол ; монстр[2] = Дьявол 

P.S. Меня заботит возможность ситуации когда сумма цен всех элементов меньше суммы группы и разница меньше цены самого дешевого 'монстра' 
Сумма группы = 7 Цены монстров 2 и 3 Может ли получиться такой вариант 2,2,2 с остатком 1 который некуда пристроить? 

P.S. После нахождения мы получаем массив.

=Aleks Versus=
в моём примере такой случай исключён. Условие

Код:
summ - (number + min('mass')) < 0
должно предотвращать такие варианты. Но цены монстров всегда должны предполагать, что может быть хотя бы один случай с монстром наименьшей стоимости. Тебе нужна функция, ОК, можно сделать универсальную вот так: 

 Спойлер Show Spoiler Hide Spoiler
 
Код:
!#enemy_search 
args[0] = args[0] & ! стоимость всех монстров (то, что было summ) 
$args[1] = $args[1]+',' & ! цены всех монстров через запятую 

! первое, что делаем, вытаскиваем цены за монстров из аргумента 
:price 
if len($args[1])>0: 
    ! запоминаем число 
    mass[]=val($mid($args[1],1,instr($args[1],",")-1)) 
    ! удаляем его из строки 
    if instr($args[1],",")<>len($args[1]): 
        $args[1]=$mid($args[1],instr($args[1],",")+1) 
    else 
        $args[1]='' 
    end 
    jump 'price' 
end 

! Теперь выполняем тот же алгоритм, что мы уже писали, 
! только исключая лишние глобальные переменные  (используем args) 

! начинается цикл. Метка: 
:for 
! выкидываем число (стоимость монстра) из массива 
    ! получаем индекс 
    args['index'] = rand(0,arrsize('mass')-1) 
    ! фиксируем число 
    args['number']=mass[args['index']] 
    
! проверяем, возможно ли вычитание 
if args[0] - args['number'] = 0: 
! если при вычитании числа из args[0] получается 0, значит мы нашли последнее число 
    ! записываем его 
    search[]=args['number'] 
elseif args[0] - args['number'] < min('mass'): 
! если разность args[0] и числа - меньше минимального значения в массиве, значит 
    ! число, которое мы вытянули, нам не подходит 
    ! и не подойдёт, его можно убрать из исходного массива 
    killvar 'mass',args['index'] 
    ! записывать его не нужно, просто возвращаемся и повторяем цикл 
    jump 'for' 
elseif args[0] - (args['number'] + min('mass')) < 0: 
! если разность между args[0] и суммой выпавшего и минимального чисел в массиве 
! меньше нуля, это число так же нам не подходит и не подойдёт 
    killvar 'mass',args['index'] 
    jump 'for' 
    ! можно объединить с предыдущим условием через оператор OR 
elseif arrsize('mass')<1: 
! защита от дурака. Если размер массива mass упал до нуля, значит мы перебрали все 
! возможные варианты и значит изначальное условие задано неверно или 
! решение, которое начал подбирать алгоритм изначально неверно подбиралось 
    ! *pl 'неверное решение' 
    ! $result = 'false' 
    jump 'endandexit' 
else 
! во всех остальных случаях число нам подходит: 
    ! запоминаем его в конечный массив 
    search[]=args['number'] 
    ! уменьшаем args[0] на это число 
    args[0] -= args['number'] 
    ! повторяем цикл 
    jump 'for' 
end 
! результат прописывается в массив search 
! массив mass удаляем, он был временным 
:endandexit 
killvar 'mass' 
exit

Пример вызова: 

Код:
gosub 'enemy_search',9,'2,3,5,9'