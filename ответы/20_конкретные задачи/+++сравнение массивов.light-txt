сравнение массивов
-----------------------------------------------------------------------
=Белый шарик=
http://qsp.su/index.php?option=com_agora&task=topic&id=40&p=131&prc=25&Itemid=57#p21159
Таки созрел для применения массива, но что-то без успехов. ) 

:opp 
win[1] = rand (1,15) 
win[2] = rand (1,15) 
fail[1] = rand (1,15) 
fail[2] = rand (1,15) 
fail[3] = rand (1,15) 
if win = fail : jump 'opp' 
gt 'nex2'
По моему разумению

if win = fail : jump 'opp'

Сверит весь массив переменных win на равенство всему массиву fail? 
Но код при исполнении почему-то зависает.

=Babai=
Что значит сверит? 

fail <> fail[1]+fail[2]+fail[3]
Распишите подробнее, что вы хотели получить 

В вашем случае win=0 и fail=0, поэтому уходит в вечный цикл. 

PS. Забыл добавить, что win=win[0]. Сразу старайтесь привыкнуть, что массивы нумеруются с 0, а не 1. Даже если вы зададите только win[1] и win[2] - размер массива будет равен 3, ибо не назначенная win[0] останеться с нулем по умолчания.

=Белый Шарик=
Ааа...  Тоесть я неправильно понимал массив вообще. 
Ну вообще хочу что бы выпадении условия, когда win[1] равен любому fail или когда win[2] равен любому fail происходил проброс рандома, пока не выпадет условие, когда win[1] И win[2] не совпадают ни с одним fail. 

Я думал что fail - обобщенный подраздел для всего массива. Как с помощью массива задать проверку нужного мне условия? 

Просто раньше громоздил формулы без массива 

if win1 = fail1 or win1 = fail2 or win1 = fail3 : jump'opp' 
if win2 = fail1 or win2 = fail2 or win2 = fail3 : jump 'opp'

Но когда в условии win1, win2, win3, win4  и 12 разных fail. Такие громозеки городить расхотелось. Вот и подумал, как бы массивом это облегчить.

=Babai=
Если такая сложная проверка между двумя большим массивам - проще сделать отдельную функцию для проверки. 

1. Сначала определим оба массива win[0]... win[x] и fail[0]...fail[x] 

2. Напишем функцию проверки, где начиная с win[0] и заканчивая win[ARRSIZE('win')-1](т.е. с первого до последнего элемента массива) идет проверка на равенство с каждым элементом из массива fail[]. 
Грубо говоря, если у вас win[2] и fail[4], пишем вложенный цикл и сравниваем: 
win[0]=fail[0], win[0]=fail[1],win[0]=fail[2],win[0]=fail[3],win[0]=fail[4] 
win[1]=fail[0], win[1]=fail[1] и тд. 
Если все нормально - выводим result=-1, если нет, то result=0 

3. В коде локации пишем 

if FUNC('функция проверки'): 
   !все ок 
else 
   !не ок, прыгаем на метку, повторяем пункт 1. 
end

=evp=
:opp 
KILLVAR 'win' 
KILLVAR 'fail' 
win[] = rand (1,15) 
win[] = rand (1,15) 
fail[] = rand (1,15) 
fail[] = rand (1,15) 
fail[] = rand (1,15) 
index_win = 0 
    :labelloop_index_win 
    if index_win <= ARRSIZE('win')-1: 
        if ARRPOS('fail',win[index_win]) <> -1: jump 'opp' 
        index_win += 1 
        jump 'labelloop_index_win' 
    end 
gt 'nex2'

=Babai=
:labelloop_index_win 
    if [b]условие[/b]: 
        [b]выполняем код[/b] 
        index_win += 1 
        jump 'labelloop_index_win' 
    end

Цикл, в данном случаем от 0, до ARRSIZE('win')-1 (размер массива win минус 1) 
К примеру, у тебя массив win состоит из 3х элементов, win[0], win[1] и win[2] 
ARRSIZE('win') - выдаст 3 (по количеству переменных в массиве, но так как массив начинается с нуля, то 'крайним' элементом будет x-1, 2 в данном примере. 

index_win = 0

Обнуляем переменную, если есть. Первый 'шаг' нашего цикла будет 0, если цикл пройдет, но еще остаются переменные в массиве - увеличим на единичку и повторим. Так для каждого элемента массива (от 0 до 2, к моему примеру) 

В данном цикле, мы проверяем все переменные в массиве win от 0 

if ARRPOS('fail',win[index_win]) <> -1: jump 'opp'

ARRPOS ищет есть ли в другом массиве - fail строка равная переменной win[с текущим индексом]. Если строка не найдена, т.е. в массиве fail нет переменной win[x]- функция выдает результат -1 и можно переходить к следующему по порядку win[x+1]. 
А если выдает результат отличный от -1, значит одна (или несколько, но в данном условии нам это не важно) переменных из массива fail равны текущей win[x] и по вашим условиям - jump 'opp' прыгаем обратно на инициализацию этих переменных. 

А вообшем, советую еще пару раз перечитать раздел справки про массивы 

ps. Перечитал свой пост, как-то сумбурно все расписал. Простите если еще больше запутал smile

=Aleks Versus=
Это натолкнуло на написание функции сравнения массивов в easy.math.